import java.util.*;public class ArrayListWithListIterator implements                                        ListWithListIteratorInterface{	private Object entry[]; // array of list entries	private int length;     // current number of entries in list	private static final int INITIAL_SIZE = 25;	public ArrayListWithListIterator()	{		length = 0;		entry = new Object[INITIAL_SIZE];	} // end default constructor	public ArrayListWithListIterator(int initialSize)	{		length = 0;		entry = new Object[initialSize];	} // end constructor	public boolean add(Object newEntry)	{		if (isArrayFull()) 			doubleArray();		// add new entry after last current entry		entry[length] = newEntry;		length++;		return true;	} // end add		//  STUDENT EXERCISE	public boolean add(int newPosition, Object newEntry)	{		boolean isSuccessful = true;		if ((newPosition >= 1) && (newPosition <= length+1)) 		{				if (isArrayFull()) 				doubleArray();							makeRoom(newPosition);							entry[newPosition-1] = newEntry;			length++;		}		else			isSuccessful = false;					return isSuccessful;	} // end add	public Object remove(int givenPosition) 	{		Object result = null;  // return value		if ((givenPosition >= 1) && (givenPosition <= length))		{			result = entry[givenPosition-1]; // get entry to be removed			// move subsequent entries toward entry to be removed, 			// unless it is last in list			if (givenPosition < length)				removeGap(givenPosition);			length--;		} // end if		return result;  // return reference to removed entry,		                // or null if givenPosition is invalid	} // end remove	public void clear()	{		length = 0;	} // end clear	public boolean replace(int givenPosition, Object newEntry)	{		boolean isSuccessful = true;		if ((givenPosition >= 1) && (givenPosition <= length))			entry[givenPosition-1] = newEntry;		else			isSuccessful = false;		return isSuccessful;	} // end replace	public Object getEntry(int givenPosition)	{		Object result = null;  // result to return		if ((givenPosition >= 1) && (givenPosition <= length))			result = entry[givenPosition-1];		return result;	} // end getEntry	public boolean contains(Object anEntry)	{		boolean found = false;		for (int index = 0; !found && (index < length); index++)		{			if (anEntry.equals(entry[index]))				found = true;		} // end for		return found;	} // end contains	public int getLength()	{		return length;	} // end getLength	public boolean isEmpty()	{		return length == 0;	} // end isEmpty	public boolean isFull()	{		return false;	} // end isFull	public void display()	{		for (int index = 0; index < length; index++)			System.out.println(entry[index]);	} // end display		private boolean isArrayFull()	// Returns true if the array of list entries is full,	{	  return length == entry.length;	} // end isArrayFull		/** Task: Doubles the size of the array of list entries. */	private void doubleArray()	{		Object[] oldList = entry;      // save reference to array of 		                               // list entries		int oldSize = oldList.length;  // save old max size of array		entry = new Object[2*oldSize]; // double size of array		// copy entries from old array to new, bigger array		for (int index = 0; index < oldSize; index++)			entry[index] = oldList[index];	} // end doubleArray	private void makeRoom(int newPosition)	{		// move each entry to next higher position, starting at end of		// list and continuing until the entry at newPosition is moved		for (int index = length; index >= newPosition; index--)			entry[index] = entry[index-1];	} // end makeRoom		/** Task: Shifts entries that are beyond the entry to be removed 	 *        to next lower position.	 *  Precondition: 1 <= givenPosition <= length;	 *                length is listâs length before removal. */	private void removeGap(int givenPosition)	{		for (int index = givenPosition; index < length; index++)			entry[index-1] = entry[index];	} // end removeGap		public ListIterator getListIterator()	{		return new IteratorForArrayList();	} // end getListIterator	private class IteratorForArrayList implements ListIterator	{		private int currentIndex;		private boolean wasNextCalled;		private boolean wasPreviousCalled;		private boolean wasAddCalled;		public IteratorForArrayList()		{			currentIndex = 0;			wasNextCalled = false;			wasPreviousCalled = false;			wasAddCalled = false;		} // end default constructor/		public boolean hasNext()		{			return currentIndex < length;		} // end hasNext		public Object next() throws NoSuchElementException		{			if (hasNext())			{				wasNextCalled = true;				wasPreviousCalled = false;				wasAddCalled = false;				Object currentEntry = entry[currentIndex];				currentIndex++;				return currentEntry;			}			else				throw new NoSuchElementException("next() called after iteration " +			                         	         "has reached end.");		} // end next		public boolean hasPrevious()		{			return (currentIndex > 0) && (currentIndex <= length);		} // end hasPrevious		public Object previous()		{			if (hasPrevious())			{				wasPreviousCalled = true;				wasNextCalled = false;				wasAddCalled = false;				currentIndex--;				return entry[currentIndex];			}			else				throw new NoSuchElementException("previous() called after " + 				                                 "iteration has reached beginning.");		} // end previous				public int nextIndex()		{			int result;			if (hasNext())				result = currentIndex;			else				result = length;			return result;		} // end nextIndex				public int previousIndex()		{			int result;			if (hasPrevious())				result = currentIndex - 1; 			else				result = -1;			return result;		} // end previousIndex		public void add(Object newEntry)		{			wasAddCalled = true;			currentIndex++;			ArrayListWithListIterator.this.add(currentIndex, newEntry);		} // end add				public void remove() throws IllegalStateException		{			if (wasNextCalled && !wasAddCalled)			{				// next() called, but add() not called;				// currentIndex is 1 more than the index of the entry 				// returned by next(), so it is the position number of 				// the entry to be removed				   ArrayListWithListIterator.this.remove(currentIndex);				   currentIndex--;				   wasNextCalled = false;				   wasPreviousCalled = false;			}			else if (wasPreviousCalled && !wasAddCalled)			{				// previous() called, but add() not called;				// currentIndex is the index of the entry returned by 				// previous(), so is 1 less than the position number of 				// the entry to be removed				   ArrayListWithListIterator.this.remove(currentIndex+1);				   wasNextCalled = false;				   wasPreviousCalled = false;			}			else				throw new IllegalStateException("next or previous not " +			             	        "called for this invocation of remove");		} // end remove				// 8.33		public void set(Object newEntry)		{			if (wasNextCalled && !wasAddCalled)				entry[currentIndex-1] = newEntry;			else if (wasPreviousCalled && !wasAddCalled)				entry[currentIndex] = newEntry;			else				throw new IllegalStateException("next() or previous() not " +				             "called for this invocation of set(), " +				             "OR remove() or add() was called after next() " +				             "or previous(), but before set().");		} // end set	} // end IteratorForArrayList} // end ArrayListWithListIterator