public class SortedList extends LinkedListBase                        implements SortedListInterface{	public boolean add(Comparable newEntry)	{				Node newNode = new Node(newEntry); // create new node		Node nodeBefore = getNodeBefore(newEntry);		if (isEmpty() || nodeBefore == null)		{			// add to beginning of list			newNode.setNextNode(getFirstNode());		//	super.setFirstNode(newNode);			setFirstNode(newNode); // super not necessary, but OK     }		else		{			// nodeBefore is not null and references the node that should be before newEntry			Node nodeAfter = nodeBefore.getNextNode();			newNode.setNextNode(nodeAfter);			nodeBefore.setNextNode(newNode);		} // end if					incrementLength();		return true;	} // end add  	public boolean remove(Comparable anEntry)	{		boolean found = false;		if (getLength() > 0)		{			Node nodeToRemove;			Node nodeBefore = getNodeBefore(anEntry);			if (nodeBefore == null)				nodeToRemove = getFirstNode();			else				nodeToRemove = nodeBefore.getNextNode();			if ((nodeToRemove != null) && anEntry.equals(nodeToRemove.getData()) )			{				found = true;				if (nodeBefore == null)							setFirstNode(nodeToRemove.getNextNode());				else				{																			Node nodeAfter = nodeToRemove.getNextNode();					nodeBefore.setNextNode(nodeAfter); 										} // end if				decrementLength();			} // end if		} // end if		return found;	} // end remove	public int getPosition(Comparable anEntry)	{		Node currentNode = super.getFirstNode();		int position = 1;				while ( (currentNode != null) && ( anEntry.compareTo(currentNode.getData()) > 0) )		{			currentNode = currentNode.getNextNode();			position++;		} // end while				// Assertion: if anEntry is in list, current references the node that contains it		// and position indicates its location in the list.		// Otherwise, position indicates where anEntry belongs in the list.		if ( (currentNode == null) || ( anEntry.compareTo(currentNode.getData()) != 0) )		{			position = -position;		}			return position;	} // end getPosition	public boolean add(int newPosition, Object newEntry)	{		throw new UnsupportedOperationException("Illegal attempt to " +			"add at a specified position within a sorted list.");		} // end add	public boolean replace(int givenPosition, Object newEntry)	{		throw new UnsupportedOperationException("Illegal attempt to " +			"replace an entry within a sorted list.");		} // end replace	private Node getNodeBefore(Comparable anEntry)	{		Node currentNode = getFirstNode();		Node nodeBefore = null;				while ( (currentNode != null) && 		        (anEntry.compareTo(currentNode.getData()) > 0) )		{			nodeBefore = currentNode;			currentNode = currentNode.getNextNode();		} // end while				return nodeBefore;	} // end getNodeBefore} // end SortedList