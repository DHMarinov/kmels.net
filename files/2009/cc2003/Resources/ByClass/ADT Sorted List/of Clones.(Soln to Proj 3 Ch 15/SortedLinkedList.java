public class SortedLinkedList implements SortedListInterface{	private Node firstNode; // reference to first node of chain	private int  length;    // number of entries in sorted list	public SortedLinkedList()	{		firstNode = null;		length = 0;	} // end default constructor	public boolean add(Sortable newEntry)	{		Node newNode = new Node(newEntry.clone());		Node nodeBefore = getNodeBefore(newEntry);		if (isEmpty() || (nodeBefore == null)) // add before first node		{			newNode.setNextNode(firstNode);			firstNode = newNode;		}		else                  // add between nodeBefore and currentNode		{			Node nodeAfter = nodeBefore.getNextNode();			newNode.setNextNode(nodeAfter);			nodeBefore.setNextNode(newNode);		} // end if		length++;		return true;	} // end add   	public boolean remove(Sortable anEntry)	{		boolean found = false;		if (length > 0)		{			Node nodeToRemove;			Node nodeBefore = getNodeBefore(anEntry);			if (nodeBefore == null)				nodeToRemove = firstNode;			else				nodeToRemove = nodeBefore.getNextNode();							if ((nodeToRemove != null) && anEntry.equals(nodeToRemove.getData()) )			{				found = true;								if (nodeBefore == null)							firstNode = nodeToRemove.getNextNode();				else				{																			Node nodeAfter = nodeToRemove.getNextNode();					nodeBefore.setNextNode(nodeAfter); 										} // end if								length--;			} // end if		} // end if				return found;	} // end remove	private Node getNodeBefore(Sortable anEntry)	{		Node currentNode = firstNode;		Node nodeBefore = null;		while ( (currentNode != null) && 		        ( anEntry.compareTo(currentNode.getData()) > 0) )		{			nodeBefore = currentNode;			currentNode = currentNode.getNextNode();		} // end while		return nodeBefore;	} // end getNodeBefore	public int getPosition(Sortable anEntry)	{		int position = 1;		Node currentNode = firstNode;				while ( (currentNode != null) && ( anEntry.compareTo(currentNode.getData()) > 0) )		{			currentNode = currentNode.getNextNode();			position++;		} // end while		if ( (currentNode == null) || anEntry.compareTo(currentNode.getData()) != 0)			position = -position;				return position;	 } // end getPosition// list ops   public Object remove(int givenPosition)   {   		Object result = null;  // return value   			if (!isEmpty() && (givenPosition >= 1) && (givenPosition <= length))		{				if (givenPosition == 1)			   // case 1: remove first entry				{				result = firstNode.getData();		// get ready to return removed entry				firstNode = firstNode.getNextNode();				}			else 							   // case 2: givenPosition > 1			{				   Node nodeBefore = getNodeAt(givenPosition-1);	// node before the one to be removed				Node nodeToRemove = nodeBefore.getNextNode();	// node to be removed				Node nodeAfter = nodeToRemove.getNextNode();	// node after the one to be removed				nodeBefore.setNextNode(nodeAfter);				// disconnect the node to be removed				result = nodeToRemove.getData();				// get ready to return removed entry			}  // end if						length--;							  				// decrease length for both cases		} // end if        return result;  // if list is empty, return null	}  // end remove		public final void clear() 	{		firstNode = null;		        length = 0;    } // end clear      public Object getEntry(int givenPosition)   {      Sortable result = null;  // result to return            if (givenPosition >= 1 && givenPosition <= length)         result = (Sortable)getNodeAt(givenPosition).getData();            return result.clone();   } // end getEntry	public boolean contains(Object anEntry)	{		return getPosition((Sortable)anEntry) > 0;	} // end contains		public int getLength()	{	  return length;	} // end getLength	public boolean isEmpty()	{	  return length == 0; // or firstNode == null	} // end isEmpty	public boolean isFull()	{	  return false;	} // end isFull	public void display()	{	  for (Node current = firstNode; current != null; current = current.getNextNode())	     System.out.println(current.getData());	} // end display	private Node getNodeAt(int givenPosition)	{		Node currentNode = firstNode;			  // traverse through list to locate the desired node		for (int counter = 1; counter < givenPosition; counter++)			currentNode = currentNode.getNextNode();		return currentNode;	} // end getNodeAt// end list ops	private class Node	{		private Object data;  // data portion		private Node	next;  // next to next node		private Node(Object dataPortion) 		{			data = dataPortion;			next = null;			} // end constructor				private Node(Object dataPortion, Node nextNode) 		{			data = dataPortion;			next = nextNode;			} // end constructor				private Object getData()		{			return data;		} // end getData				private void setData(Object newData)		{			data = newData;		} // end setData				private Node getNextNode()		{			return next;		} // end getNextNode				private void setNextNode(Node nextNode)		{			next = nextNode;		} // end setNextNode	} // end Node} // end SortedLinkedList