/******************************************************************** * Class for sorting an array of Comparable objects from smallest to  * largest. ********************************************************************/public class SortArray{	public static final int MIN_SIZE = 5; // for quick sort// SELECTION SORT// 11.6	/** Task: Sorts the first n objects in an array into ascending order.	 *  @param a  an array of Comparable objects	 *  @param n  an integer > 0 */	public static void selectionSort(Comparable[] a, int n)	{		selectionSort(a, 0, n-1); // invoke recursive method	} // end selectionSort// Based on pseudocode in 11.5	public static void selectionSort(Comparable[] array, int first, int last)	{		if (first < last)		{  // place the smallest value at beginning of array:			int indexOfNextSmallest = indexOfSmallest(array, first, last);			swap(array, first, indexOfNextSmallest);			selectionSort(array, first+1, last);		} // end if	} // end selectionSort	/** Task: Determines the index of the smallest value in an array.	 *  @param a      an array of Comparable objects	 *  @param first  an integer > 0 that is the index of the first	 *                array element to consider	 *  @param last   an integer > 0 that is the index of the last	 *                array element to consider	 *  @return the index of the smallest value among	 *          a[first], a[first+1], . . . , a[last] */	private static int indexOfSmallest(Comparable[] a, int first, int last)	{		Comparable min = a[first];		int indexOfMin = first;		for (int index = first+1; index <= last; index++)		{			if (a[index].compareTo(min) < 0)			{				min = a[index];				indexOfMin = index;				// Assertion: min is the smallest of a[first] through a[index].			} // end if		} // end for		return indexOfMin;	} // end indexOfSmallest	/** Task: Swaps the array elements array[i] and array[j]. */	private static void swap(Comparable[] a, int i, int j)	{		Comparable temp = a[i];		a[i] = a[j];		a[j] = temp; 	} // end swap	// ALTERNATE VERSIONS	public static void selectionSort2(Comparable[] array, int n)	{		if (n > 1)		{   // place the largest value at end of array:			swap(array, indexOfLargest(array, 0, n-1), n-1);			selectionSort2(array, n-1);		} // end if	} // end selectionSort2		public static void selectionSort3(Comparable[] array, int first, int last)	{		if (first < last)		{   // place the largest value at end of array:			swap(array, indexOfLargest(array, first, last), last);			selectionSort3(array, first, last-1);		} // end if	} // end selectionSort3	/** Task: Determines the index of the largest value in an array.	 *  @param a      an array of Comparable objects	 *  @param first  an integer > 0 that is the index of the first	 *                array element to consider	 *  @param last   an integer > 0 that is the index of the last	 *                array element to consider	 *  @return the index of the smallest value among	 *          a[first], a[first+1], . . . , a[last] */	private static int indexOfLargest(Comparable[] a, int first, int last)	{		Comparable max = a[first];		int indexOfMax = first;		for (int index = first+1; index <= last; index++)		{			if (a[index].compareTo(max) > 0)			{				max = a[index];				indexOfMax = index;				// Assertion: max is the largest of a[first] through a[index].			} // end if		} // end for		return indexOfMax;	} // end indexOfLargest// -------------------------------------------------------------------------------// INSERTION SORT	public static void insertionSort(Comparable[] array, int n)	{		insertionSort(array, 0, n-1);	} // end insertionSort	// 11.10	public static void insertionSort(Comparable[] a, int first, int last)	{		if (first < last)		{			// sort all but the last element			insertionSort(a, first, last-1); 			// insert the last element in sorted order			insertInOrder(a[last], a, first, last-1); 		} // end if	} // end insertionSort	// Based on pseudocode in 11.12	private static void insertInOrder(Comparable element, Comparable[] array, int first, int last)	{	// Inserts item into the sorted array a[first] through a[last]			if (element.compareTo(array[last]) >= 0)			array[last+1] = element;		else if (first < last)		{			array[last+1] = array[last];			insertInOrder(element, array, first, last-1);		} 		else		{			array[last+1] = array[last];			array[last] = element;		} // end if		} // end insertInOrder	// ALTERNATE VERSION	public static void insertionSort2(Comparable[] array, int first, int last)	{		if (first < last)		{			insertionSort2(array, first, last-1);  // sort all but last item			insertInOrder(array[last], array, first, last-1); // insert last item in 			                                                  // sorted order		} // end  if	} // end insertionSort2// -------------------------------------------------------------------------------// BUBBLE SORT	public static void recursiveBubbleSort(Comparable[] array, int n)	{		if (n > 1)		{	for (int index = 0; index < n - 1; index++)				order(array, index, index + 1);			recursiveBubbleSort(array, n-1);		}  // end if	}  // end recursiveBubbleSort // -------------------------------------------------------------------------------// MERGE SORT	public static void mergeSort(Comparable[] array, int n)	{		mergeSort(array, 0, n-1);	} // end mergeSort		public static void mergeSort(Comparable[] array, int first, int last)	{	   if (first < last)	   {  // sort each half	      int mid = (first + last)/2;    // index of midpoint	      mergeSort(array, first, mid);  // sort left half array[first..mid]	      mergeSort(array, mid+1, last); // sort right half array[mid+1..last]			if (array[mid].compareTo(array[mid+1]) > 0)  // Question 2	     	 	merge(array, first, mid, last); // merge the two halves	   //	else skip merge step	   }  // end if	}  // end mergeSort		private static void merge(Comparable[] array, int first, int mid, int last)	{ // ITERATIVE		// Two adjacent subarrays are array[beginHalf1..endHalf1] and array[beginHalf2..endHalf2].		int beginHalf1 = first;		int endHalf1 = mid;		int beginHalf2 = mid + 1;		int endHalf2 = last;	   Comparable[] tempArray = new Comparable[array.length];    // temporary array		// while both subarrays are not empty, copy the	   // smaller item into the temporary array		int index = beginHalf1;    // next available location in								// tempArray		for (; (beginHalf1 <= endHalf1) && (beginHalf2 <= endHalf2); index++)	   {  // Invariant: tempArray[beginHalf1..index-1] is in order	   	      if (array[beginHalf1].compareTo(array[beginHalf2]) < 0)	      {  	      	tempArray[index] = array[beginHalf1];	         beginHalf1++;	      }	      else	      {  	      	tempArray[index] = array[beginHalf2];	         beginHalf2++;	      }  // end if	   }  // end for	   // finish off the nonempty subarray	   // finish off the first subarray, if necessary	   for (; beginHalf1 <= endHalf1; beginHalf1++, index++)	      // Invariant: tempArray[beginHalf1..index-1] is in order	      tempArray[index] = array[beginHalf1];	   // finish off the second subarray, if necessary		for (; beginHalf2 <= endHalf2; beginHalf2++, index++)	      // Invariant: tempArray[beginHalf1..index-1] is in order	      tempArray[index] = array[beginHalf2];			   // copy the result back into the original array	   for (index = first; index <= last; index++)	      array[index] = tempArray[index];	}  // end merge// -------------------------------------------------------------------------------// QUICK SORT	public static void quickSort(Comparable[] array, int n)	{		quickSort(array, 0, n-1);	} // end quickSort// 12.17		/** Task: Sorts an array into ascending order. Uses quick sort with 	 *        median-of-three pivot selection for arrays larger than	 *        MIN_SIZE elements, and uses insertion sort for other arrays. */	public static void quickSort(Comparable[] array, int first, int last)	{   	if (last - first + 1 < MIN_SIZE)   		insertionSort(array, first, last);   	else   	{	   	// create the partition: Smaller | Pivot | Larger	      int pivotIndex = partition(array, first, last);	      	      // sort subarrays Smaller and Larger	      quickSort(array, first, pivotIndex-1);	      quickSort(array, pivotIndex+1, last);      } // end if	}  // end quickSort// 12.15	/** Task: Sorts the first, middle, and last elements of an 	 *        array into ascending order.	 *  @param a      an array of Comparable objects	 *  @param first  the integer index of the first array element; first >= 0	 *  @param mid    the integer index of the middle array element	 *  @param last   the integer index of the last array element; 	 *                last - first >= 2, last < a.length */	private static void sortFirstMiddleLast(Comparable[] a, int first,	                                        int mid, int last)	{		order(a, first, mid); // make a[first] <= a[mid]		order(a, mid, last);  // make a[mid] <= a[last]		order(a, first, mid); // make a[first] <= a[mid]	} // end sortFirstMiddleLast	/** Task: Orders two given array elements into ascending order	 *        so that a[i] <= a[j]. */	private static void order(Comparable[] a, int i, int j)	{		if (a[i].compareTo(a[j]) > 0)		swap(a, i, j);	} // end order// 12.16	/** Task: Partitions an array as part of quick sort into two subarrays	 *        called Smaller and Larger that are separated by a single	 *        element called the pivot. 	 *        Elements in Smaller are left of the pivot and <= pivot.	 *        Elements in Larger are right of the pivot and >= pivot.	 *  @param a      an array of Comparable objects	 *  @param first  the integer index of the first array element; 	 *                first >= 0	 *  @param last   the integer index of the last array element; 	 *                last - first >= 3; last < a.length	 *  @return the index of the pivot */	private static int partition(Comparable[] a, int first, int last)	{		int mid = (first + last)/2;		sortFirstMiddleLast(a, first, mid, last);		// Assertion: The pivot is a[mid]; a[first] <= pivot and 		// a[last] >= pivot, so do not compare these two array elements		// with pivot.		// move pivot to next-to-last position in array		swap(a, mid, last-1);		int pivotIndex = last-1;		Comparable pivot = a[pivotIndex];		// determine subarrays Smaller = a[first..endSmaller]		//                 and Larger  = a[endSmaller+1..last-1]		// such that elements in Smaller are <= pivot and 		// elements in Larger are >= pivot; initially, these subarrays are empty		int indexFromLeft = first+1; 		int indexFromRight = last - 2; 		boolean done = false;		while (!done)		{			// starting at beginning of array, leave elements that are < pivot; 			// locate first element that is >= pivot; you will find one,			// since last element is >= pivot			while (a[indexFromLeft].compareTo(pivot) < 0)				indexFromLeft++;			// starting at end of array, leave elements that are > pivot; 			// locate first element that is <= pivot; you will find one, 			// since first element is <= pivot			while (a[indexFromRight].compareTo(pivot) > 0)				indexFromRight--;			// Assertion: a[indexFromLeft] >= pivot and 			//            a[indexFromRight] <= pivot.			if (indexFromLeft < indexFromRight)			{				swap(a, indexFromLeft, indexFromRight);				indexFromLeft++;				indexFromRight--;			}			else 				done = true;		} // end while		// place pivot between Smaller and Larger subarrays		swap(a, pivotIndex, indexFromLeft);		pivotIndex = indexFromLeft;		// Assertion:		// Smaller = a[first..pivotIndex-1]		// Pivot = a[pivotIndex]		// Larger  = a[pivotIndex + 1..last]		return pivotIndex; 	}  // end partition} // end SortArray