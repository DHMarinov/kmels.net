/******************************************************************** * Class for sorting an array of Comparable objects from smallest to  * largest. ********************************************************************/public class SortArray{// SELECTION SORT// 11.4	/** Task: Sorts the first n objects in an array into ascending order.	 *  @param a  an array of Comparable objects	 *  @param n  an integer > 0 */	public static void selectionSort(Comparable[] a, int n)	{		for (int index = 0; index < n - 1; index++)		{			int indexOfNextSmallest = indexOfSmallest(a, index, n-1);			swap(a, index, indexOfNextSmallest);			// Assertion: a[0] <= a[1] <= . . . <= a[index] <= all other a[i]		} // end for	} // end selectionSort	/** Task: Determines the index of the smallest value in an array.	 *  @param a      an array of Comparable objects	 *  @param first  an integer > 0 that is the index of the first	 *                array element to consider	 *  @param last   an integer > 0 that is the index of the last	 *                array element to consider	 *  @return the index of the smallest value among	 *          a[first], a[first+1], . . . , a[last] */	private static int indexOfSmallest(Comparable[] a, int first, int last)	{		Comparable min = a[first];		int indexOfMin = first;		for (int index = first+1; index <= last; index++)		{			if (a[index].compareTo(min) < 0)			{				min = a[index];				indexOfMin = index;				// Assertion: min is the smallest of a[first] through a[index].			} // end if		} // end for		return indexOfMin;	} // end indexOfSmallest	/** Task: Swaps the array elements a[i] and a[j].	 *  @param a  an array of Comparable objects	 *  @param i  an integer >= 0 and < a.length	 *  @param j  an integer >= 0 and < a.length */	private static void swap(Comparable[] a, int i, int j)	{		Comparable temp = a[i];		a[i] = a[j];		a[j] = temp; 	} // end swap// -------------------------------------------------------------------------------// INSERTION  SORT		public static void insertionSort(Comparable[] array, int n)	{		insertionSort(array, 0, n-1);	} // end insertionSort	public static void insertionSort(Comparable[] array, int first, int last)	{		int unsorted, index;				for (unsorted = first+1; unsorted <= last; unsorted++)		{   // Assertion: array[first] <= array[first+1] <= ... <= array[unsorted-1]					Comparable firstUnsorted = array[unsorted];						insertInOrder(firstUnsorted, array, first, unsorted-1);		} // end for	} // end insertionSort	private static void insertInOrder(Comparable element, Comparable[] array, int begin, int end)	{		int index  = end;				while ((index >= begin) && (element.compareTo(array[index]) < 0))		{			array[index+1] = array[index]; // make room			index--;		} // end while		// Assertion: array[index+1] is available				array[index+1] = element;  // insert	} // end insertInOrder// -------------------------------------------------------------------------------// SHELL SORT// 11.21	/** Task: Sorts equally spaced elements of an array into	 *  ascending order.	 *  @param a an array of Comparable objects	 *  @param first an integer >= 0 that is the index of the first	 *  array element to consider	 *  @param last an integer >= first and < a.length that is the	 *  index of the last array element to consider	 *  @param space the difference between the indices of the	 *  elements to sort */	public static void shellSort(Comparable[] array, int first, int last)	{		int n = last - first + 1; // number of array elements				for (int space = n/2; space > 0; space = space/2)		{			for (int begin = first; begin < first + space; begin++)				incrementalInsertionSort(array, begin, last, space);		} // end for	} // end shellSort		/** avoids even spacing */	public static void shellSortNoEven(Comparable[] array, int first, int last)	{		int n = last - first + 1; // number of array elements				for (int space = n/2; space > 0; space = space/2)		{			if (space%2 == 0) // if space is even, add 1				space++;			for (int begin = first; begin < first + space; begin++)				incrementalInsertionSort(array, begin, last, space);		} // end for	} // end shellSortNoEven		/** Task: Sorts equally-spaced elements of an array into ascending order.	 *  @param array An array of Comparable objects.	 *  @param first An integer >= 0 that is the index of the first	 *               array element to consider.	 *  @param last  An integer >= first and < array.length that is the index of the last	 *               array element to consider.	 *  @param space The distance between the indexes of the elements to sort. */ 	private static void incrementalInsertionSort(Comparable[] array, int first, int last, int space)	{		int unsorted, index;				for (unsorted = first + space; unsorted <= last; unsorted = unsorted + space)		{   					Comparable firstUnsorted = array[unsorted];						for (index = unsorted - space; 			    (index >= first) && (firstUnsorted.compareTo(array[index]) < 0); index = index - space)			{				array[index + space] = array[index]; 			} // end for						array[index + space] = firstUnsorted;  		} // end for	} // end incrementalInsertionSort// -------------------------------------------------------------------------------	// EXERCISE: BUBBLE SORT	public static void bubbleSort(Comparable[] array, int n)	{		for (int lastIndex = n - 1; lastIndex > 0; lastIndex--)		{				for (int index = 0; index < lastIndex; index++)				order(array, index, index + 1);		}	} // end bubbleSort		private static void order(Comparable[] array, int i, int j)	{		if (array[i].compareTo(array[j]) > 0)			swap(array, i, j);	    // Assertion: array[j] is larger 	}  // end order 		// ALTERNATE VERSION	public static void betterBubbleSort(Comparable[] array, int n)	{		for (int lastIndex = n - 1; lastIndex > 0; lastIndex--)		{			int lastSwapIndex = 0;			for (int index = 0; index < lastIndex; index++)			{				if (array[index].compareTo(array[index + 1]) > 0)				{					swap(array, index, index + 1);					lastSwapIndex = index;				} // end if			} // end for			lastIndex = lastSwapIndex + 1;		} // end for	}  // end betterBubbleSort// -------------------------------------------------------------------------------// MERGE SORT	public static void mergeSort(Comparable[] array, int n)	{		int beginLeftovers = n;				for (int segmentLength = 1; segmentLength <= n/2; segmentLength = 2*segmentLength)		{			beginLeftovers = mergeSegmentPairs(array, n, segmentLength);			// 2 full segments do not remain at end; the following are possibilites:			//  a. one full segment and a partial second segment			//  b. one full segment only			//  c. one partial segment			//  d. nothing is left at end			int endSegment = beginLeftovers + segmentLength - 1;						if (endSegment < n - 1)			// Case a: one full segment and a partial second segment exist, so merge them				merge(array, beginLeftovers, endSegment, n-1);			// else Cases b, c, or d: only one full or partial segment is left (leave it in place)			//                        or nothing is left		} // end for		// merge sorted leftovers, if any, with rest of sorted array		if (beginLeftovers < n)			merge(array, 0, beginLeftovers-1, n-1);	} // end mergeSort		/** Task: Merges pairs of segments of a given length within an array 	 *        and returns the index after the last merged pair. */	private static int mergeSegmentPairs(Comparable[] array, int n, int segmentLength)	{		int mergedPairLength = 2 * segmentLength; // length of two merged segments		int numberOfPairs = n/mergedPairLength;				int beginSegment1 = 0;				for (int count = 1; count <= numberOfPairs; count++)		{			int endSegment1 = beginSegment1 + segmentLength - 1;			int beginSegment2 = endSegment1 + 1;			int endSegment2 = beginSegment2 + segmentLength - 1;						merge(array, beginSegment1, endSegment1, endSegment2);						beginSegment1 = endSegment2 + 1;		} // end for				return beginSegment1; // return index of element after last merged pair	}  // end mergeSegmentPairs	private static void merge(Comparable[] array, int first, int mid, int last)	{ 		// Two adjacent subarrays are array[beginHalf1..endHalf1] and array[beginHalf2..endHalf2].		int beginHalf1 = first;		int endHalf1 = mid;		int beginHalf2 = mid + 1;		int endHalf2 = last;	   Comparable[] tempArray = new Comparable[array.length];    // temporary array		// while both subarrays are not empty, copy the	   // smaller item into the temporary array		int index = beginHalf1;    // next available location in								// tempArray		for (; (beginHalf1 <= endHalf1) && (beginHalf2 <= endHalf2); index++)	   {  // Invariant: tempArray[beginHalf1..index-1] is in order	   	      if (array[beginHalf1].compareTo(array[beginHalf2]) < 0)	      {  	      	tempArray[index] = array[beginHalf1];	         beginHalf1++;	      }	      else	      {  	      	tempArray[index] = array[beginHalf2];	         beginHalf2++;	      }  // end if	   }  // end for	   // finish off the nonempty subarray	   // finish off the first subarray, if necessary	   for (; beginHalf1 <= endHalf1; beginHalf1++, index++)	      // Invariant: tempArray[beginHalf1..index-1] is in order	      tempArray[index] = array[beginHalf1];	   // finish off the second subarray, if necessary		for (; beginHalf2 <= endHalf2; beginHalf2++, index++)	      // Invariant: tempArray[beginHalf1..index-1] is in order	      tempArray[index] = array[beginHalf2];			   // copy the result back into the original array	   for (index = first; index <= last; index++)	      array[index] = tempArray[index];	}  // end merge// -------------------------------------------------------------------------------// HEAP SORT// 27.18	public static void heapSort(Comparable[] array, int n)	{		// create heap			for (int index = n/2; index >= 0; index--)			reheap(array, index, n-1);					swap(array, 0, n-1);				for (int last = n-2; last > 0; last--)		{			reheap(array, 0, last);			swap(array, 0, last);				} // end for		} // end heapSort		private static void reheap(Comparable[] heap, int first, int last) 	{		boolean done = false;		Comparable orphan = heap[first];		int largerChildIndex = 2*first; // index of left child, if any		while (!done && (largerChildIndex <= last) )		{			int rightChildIndex = largerChildIndex + 1;			if ( (rightChildIndex <= last) && 			      heap[rightChildIndex].compareTo(heap[largerChildIndex]) > 0 )			{				largerChildIndex = rightChildIndex;						}								if (orphan.compareTo(heap[largerChildIndex]) < 0)			{				heap[first] = heap[largerChildIndex];					first = largerChildIndex;				largerChildIndex = 2*first; // index of next left child			} 			else				done = true;			} // end while				heap[first] = orphan;	} // end reheap} // end SortArray