import java.lang.*; // UnsupportedOperationExceptionimport java.util.*; // Iteratorpublic class SortedLinkedDictionary implements DictionaryInterface,                                               java.io.Serializable{	private int  currentSize; // number of entries 	private Node firstNode;   // reference to first node of chain	public SortedLinkedDictionary()	{		firstNode = null;		currentSize = 0;	} // end default constructor	public Object add(Object key, Object value)	{		Object result = null;		Node newNode = new Node(key, value);  // create new node		Node currentNode = firstNode;		Node nodeBefore = null;		Comparable cKey = (Comparable) key;		// search chain until you either find a node containing key		// or pass the point where it should be		while ( (currentNode != null)				 && cKey.compareTo(currentNode.getKey()) > 0 )		{			nodeBefore = currentNode;			currentNode = currentNode.getNextNode();		} // end while		if ( (currentNode != null) && key.equals(currentNode.getKey()) )		{			result = currentNode.getKey();			currentNode.setValue(value);  // replace value		}				else if (isEmpty() || (nodeBefore == null))		{			newNode.setNextNode(firstNode);			firstNode = newNode;			currentSize++;		}		else // add elsewhere in non-empty list		{			newNode.setNextNode(currentNode);			nodeBefore.setNextNode(newNode);			currentSize++;		} // end if		return result;	} // end add	public Object remove(Object key)	{		Object result = null;  // return value		if (!isEmpty())		{				Node currentNode = firstNode;			Node nodeBefore = null;					  // traverse through list until either you find the desired node or		  // pass the point where it should be			while ( (currentNode != null) && 			        (((Comparable)key).compareTo(currentNode.getKey()) > 0) )			{				nodeBefore = currentNode;				currentNode = currentNode.getNextNode();			} // end while			if ( (currentNode != null) && key.equals(currentNode.getKey()) )			{				Node nodeAfter = currentNode.getNextNode();				// node after the one to be removed				if (nodeBefore == null)				{					firstNode = nodeAfter;				}				else				{					nodeBefore.next = nodeAfter;						// disconnect the node to be removed				} // end if				result = currentNode.getValue();						// get ready to return removed entry				--currentSize;							  						// decrease length for both cases			} // end if		} // end if		return result;  	} // end remove	public Object getValue(Object key)	{		Object result = null;		Node currentNode = firstNode;		// traverse through list until either you find the desired node or		// pass the point where it should be		while ( (currentNode != null) && (((Comparable)key).compareTo(currentNode.getKey()) > 0) )		{			currentNode = currentNode.getNextNode();		} // end while		if ( (currentNode != null) && key.equals(currentNode.getKey()) )		{			result = currentNode.getValue();		}		return result;	} // end getValue	public boolean contains(Object key)	{		return getValue(key) != null; 	} // end contains	public boolean isEmpty()	{		return currentSize == 0;	} // end isEmpty	public boolean isFull()	{		return false;	} // end isFull	public int getSize()	{		return currentSize;	} // end getSize	public final void clear()	{		firstNode = null;				currentSize = 0;	} // end clear	public Iterator getKeyIterator()	{		return new KeyIterator();	} // end getKeyIterator	public Iterator getValueIterator()	{		return new ValueIterator();	} // end getValueIterator	public void display()	{		Node currentNode = firstNode;		while (currentNode != null)		{		System.out.println(currentNode.getKey() + " " + currentNode.getValue());			currentNode = currentNode.getNextNode();		} // end while		System.out.println();	} // end display		private class Node	{		private Object entryKey;		private Object entryValue;		private Node	next;  // link to next node		private Node(Object key, Object value)		{			entryKey = key;			entryValue = value;			next = null;			} // end constructor				private Node(Object key, Object value, Node nextPortion)		{			entryKey = key;			entryValue = value;			next = nextPortion;			} // end constructor				private Object getKey()		{			return entryKey;		} // end getKey				private Object getValue()		{			return entryValue;		} // end getValue		// no setKey!!		private void setValue(Object newValue)		{			entryValue = newValue;		} // end setValue		private Node getNextNode()		{			return next;		} // end getNextNode				private void setNextNode(Node nextNode)		{			next = nextNode;		} // end setNextNode	} // end Node	private class KeyIterator implements Iterator	{		private Node currentNode; // marks current place in iteration		private KeyIterator()		{			currentNode = firstNode;		} // end default constructor// methods are public to match the interface Iterator 		public boolean hasNext() 		{			return currentNode != null;		} // end hasNext		public Object next()		{			Object result;			if (hasNext())			{				result = currentNode.getKey();				currentNode = currentNode.getNextNode();			}			else				throw new NoSuchElementException(); // in java.util			return result;		} // end next		public void remove()		{			throw new UnsupportedOperationException(); // in java.lang		} // end remove	} // end KeyIterator	private class ValueIterator implements Iterator	{		private Node currentNode;				private ValueIterator()		{			currentNode = firstNode;		} // end default constructor		// methods are public to match the interface Iterator 		public boolean hasNext() 		{			return currentNode != null;		} // end hasNext				public Object next()		{			Object result;						if (hasNext())			{				result = currentNode.getValue();				currentNode = currentNode.getNextNode();			}			else			{				throw new NoSuchElementException(); // in java.util			}					return result;		} // end next				public void remove()		{			throw new java.lang.UnsupportedOperationException(); // in java.lang		} // end remove	} // end ValueIterator} // end SortedLinkedDictionary