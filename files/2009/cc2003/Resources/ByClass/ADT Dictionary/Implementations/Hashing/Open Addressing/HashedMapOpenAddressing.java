// Defines locate() and probe()import java.lang.*; // UnsupportedOperationExceptionimport java.util.*; // Iteratorimport java.io.Serializable;public class HashedMapOpenAddressing implements DictionaryInterface,                                                java.io.Serializable{	private TableEntry[] hashTable; // dictionary entries	private int currentSize;         // current number of entries	private static final int DEFAULT_SIZE = 101; // must be prime	// fraction of hash table that can be filled	private static final double MAX_LOAD_FACTOR = 0.5; 	public HashedMapOpenAddressing()	{		hashTable = new TableEntry[DEFAULT_SIZE];		currentSize = 0;	} // end default constructor	public HashedMapOpenAddressing(int tableSize)	{		// ensure that table is prime size at least as big as user wants		int primeSize = getNextPrime(tableSize);				hashTable = new TableEntry[primeSize];		currentSize = 0;	} // end constructor// -------------------------// We've added this method to display the hash table for illustration and testing// -------------------------   	public void display()     	{		for (int index = 0; index < hashTable.length; index++)		{	      	if (hashTable[index] == null)	      		System.out.println("null ");	       	else if (hashTable[index].isRemoved())	      		System.out.println("notIn ");	       	else	      		System.out.println(hashTable[index].getKey() + " " + hashTable[index].getValue());		} // end for    	System.out.println();   	} // end display// -------------------------	public Object add(Object key, Object value)	{		Object oldValue; // value to return		if (isHashTableTooFull())			rehash();		int index = getHashIndex(key);		index = probe(index, key); // check for and resolve collision		// Assertion: index is within legal range for hashTable		if ( (hashTable[index] == null) || hashTable[index].isRemoved())		{ // key not found, so insert new entry			hashTable[index] = new TableEntry(key, value);			currentSize++;			oldValue = null;		}		else		{ // key found; get old value for return and then replace it			oldValue = hashTable[index].getValue();			hashTable[index].setValue(value);		} // end if		return oldValue;	} // end add	public Object remove(Object key)	{		Object result = null;		int index = getHashIndex(key);		index = locate(index, key);		if (index != -1)		{ // key found; flag entry as removed and return its value			hashTable[index].setToRemoved();			result = hashTable[index].getValue();			currentSize--;		} // end if		// else key not found; result is null		return result;	} // end remove	public Object getValue(Object key)	{		Object result = null;		int index = getHashIndex(key);		index = locate(index, key);		if (index != -1)			result = hashTable[index].getValue(); // key found; get value		// else key not found; result is null		return result;	} // end getValue	/** @return either the index of the table location that references	            the entry containing key or -1 if no such entry is found */	private int locate(int index, Object key)	{		boolean found = false;		boolean repeatedIndex = false;		int firstIndex = index;	// first index in sequence		while ( !found && !repeatedIndex && (hashTable[index] != null) )		{			if ( hashTable[index].isIn() && key.equals(hashTable[index].getKey()) )				found = true; // key found			else // follow probe sequence				index = (index + 1) % hashTable.length; // linear probing			if (firstIndex == index)				repeatedIndex = true;		} // end while		// Assertion: either key is found or a null location is reached		int result = -1;		if (found)			result = index;		return result;	} // end locate	private int probe(int index, Object key)	{		boolean found = false;		boolean repeatedIndex = false;		int firstIndex = index;  // first index in sequence		int removedStateIndex = -1; // index of first location in		                            // removed state				while ( !found && !repeatedIndex && (hashTable[index] != null) )		{			if (hashTable[index].isRemoved())			{				// save index of first not-in-use location found				if (removedStateIndex == -1)					removedStateIndex = index;				index = (index + 1) % hashTable.length; // linear probing			}			else if (key.equals(hashTable[index].getKey()))				found = true; // key found			else // follow probe sequence				index = (index + 1) % hashTable.length; // linear probing			if (index == firstIndex)				repeatedIndex = true; // probe sequence is repeating		} // end while		// Assertion: either key or null is found at hashTable[index]		if (found || (removedStateIndex == -1) )			return index; // index of either key or null		else			return removedStateIndex;	} // end probe	public boolean contains(Object key)	{		return getValue(key) != null; 	} // end contains	public boolean isEmpty()	{		return currentSize == 0;	} // end isEmpty	public boolean isFull()	{		return false;	} // end isFull	public int getSize()	{		return currentSize;	} // end getSize	public final void clear()	{		currentSize = 0;	} // end clear	//	private int getHashIndex(Object key)	public int getHashIndex(Object key)	{		int hashIndex = key.hashCode() % hashTable.length;		if (hashIndex < 0)			hashIndex = hashIndex + hashTable.length;		return hashIndex;	} // end getHashIndex	private void rehash()	{		TableEntry[] oldTable = hashTable;		int oldSize = hashTable.length;		int newSize = getNextPrime(oldSize + oldSize);		hashTable = new TableEntry[newSize]; // increase size of array		currentSize = 0; // reset size of dictionary, since it will be		                 // incremented by add during rehash		// rehash dictionary entries from old array to the new and bigger 		// array; skip both null locations and removed entries		for (int index = 0; index < oldSize; index++)		{			if ( (oldTable[index] != null) && oldTable[index].isIn() )				add(oldTable[index].getKey(), oldTable[index].getValue());		} // end for	} // end rehash	private boolean isHashTableTooFull()	{		return currentSize >= MAX_LOAD_FACTOR * hashTable.length;	} // end isHashTableTooFull	private int getNextPrime(int integer)	{		// if even, add 1 to make odd	   	if (integer % 2 == 0)		{			integer++;		} // end if		// test odd integers		while(!isPrime(integer))		{			integer = integer + 2;		} // end while		return integer;	} // end getNextPrime	private boolean isPrime(int integer)	{		boolean result;		boolean done = false;				// 2 and 3 are prime		if ( (integer == 2) || (integer == 3) )		{			result = true;		}				// 1 and even numbers are not prime		else if ( (integer == 1) || (integer % 2 == 0) )	  	{			result = false; 		}				// Assertion: integer is odd and >= 5.		else		{			// a prime is odd and not divisible by every odd integer up to its square root			result = true; // assume prime			for (int divisor = 3; !done && (divisor * divisor <= integer); divisor = divisor + 2)			{		   	if (integer % divisor == 0)	      	{					result = false; // divisible; not prime					done = true;				} // end if			} // end for		} // end if	   			return result;	} // end isPrime	public Iterator getKeyIterator()	{ 		return new KeyIterator();	} // end getKeyIterator		public Iterator getValueIterator()	{			return new ValueIterator();	} // end getValueIterator	private class KeyIterator implements Iterator	{		private int currentIndex; // current position in hash table		private int numberLeft;   // number of entries left in iteration		private KeyIterator() 		{			currentIndex = 0;			numberLeft = currentSize;		} // end default constructor		public boolean hasNext() 		{			return numberLeft > 0; 		} // end hasNext		public Object next()		{			Object result = null;			if (hasNext())			{				// find index of next entry				while ( (hashTable[currentIndex] == null) || 				         hashTable[currentIndex].isRemoved() ) 				{					currentIndex++;				} // end while				result = hashTable[currentIndex].getKey();				numberLeft--;				currentIndex++;			}			else				throw new NoSuchElementException();			return result;		} // end next		public void remove()		{			throw new UnsupportedOperationException();		} // end remove	} // end KeyIterator	private class ValueIterator implements Iterator	{		private int currentIndex;		private int numberLeft; 				private ValueIterator() 		{			currentIndex = 0;			numberLeft = currentSize;		} // end default constructor				public boolean hasNext() 		{			return numberLeft > 0; 		} // end hasNext				public Object next()		{			Object result = null;						if (hasNext())			{				while ( (currentIndex < hashTable.length) && 				        ( (hashTable[currentIndex] == null) || hashTable[currentIndex].isRemoved() ) )				{					currentIndex++;				} // end while								result = hashTable[currentIndex].getValue();				numberLeft--;				currentIndex++;			}			else			{				throw new NoSuchElementException();			}					return result;		} // end next				public void remove()		{			throw new UnsupportedOperationException();		} // end remove	} // end ValueIterator	private class TableEntry implements java.io.Serializable	{		private Object entryKey;		private Object entryValue;		private boolean inTable; // true if entry is in table, false if entry was removed				private TableEntry(Object key, Object value)		{			entryKey = key;			entryValue = value;			inTable = true;		} // end constructor				public Object getKey()		{			return entryKey;		} // end getKey				public Object getValue()		{			return entryValue;		} // end getValue				public void setValue(Object newValue)		{			entryValue = newValue;		} // end setValue		public boolean isIn()		{			return inTable;		} // end isIn				public boolean isRemoved() // opposite of contains		{			return !inTable;		} // end isRemoved		// state = true means entry in use; false means entry not in use, i.e. deleted		public void setToRemoved()		{			inTable = false;		} // end setToRemoved				public void setToIn() // not used		{			inTable = true;		} // end setToIn				public boolean equals(Object other)		{			return inTable && ((TableEntry)other).entryKey.equals(this.entryKey) && 			                  ((TableEntry)other).entryValue.equals(this.entryValue);			                  		} // end equals	} // end TableEntry	} // end HashedMapOpenAddressing