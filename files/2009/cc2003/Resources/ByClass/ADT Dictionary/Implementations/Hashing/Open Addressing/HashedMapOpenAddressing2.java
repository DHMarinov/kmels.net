// One version of probe for add, remove, getValueimport java.lang.*; // UnsupportedOperationExceptionimport java.util.*; // Iteratorimport java.io.Serializable; // public class HashedMapOpenAddressing implements DictionaryInterface, Serializable{	private TableEntry [] hashTable;					// dictionary entries	private int currentSize;                 			// current number of entries	private static final int DEFAULT_SIZE = 101; 		// default size of hash table - must be prime 	private static final double MAX_LOAD_FACTOR = 0.5;  // fraction of hash table that can be filled		public HashedMapOpenAddressing()	{		hashTable = new TableEntry[DEFAULT_SIZE];		currentSize = 0;	} // end default constructor	public HashedMapOpenAddressing(int tableSize)	{		// ensure that table is prime size at least as big as user wants		// if maxsize is prime, do not change it		int primeSize = getNextPrime(tableSize);				hashTable = new TableEntry[primeSize];		currentSize = 0;	} // end constructor	// -------------------------// We've added this method to display the hash table for illustration and testing// -------------------------   	public void display()     	{		for (int index = 0; index < hashTable.length; index++)		{	      	if (hashTable[index] == null)	      		System.out.println("null ");	       	else if (hashTable[index].isRemoved())	      		System.out.println("notIn ");	       	else	      		System.out.println(hashTable[index].getKey() + " " + hashTable[index].getValue());		} // end for    	System.out.println();   	} // end display// -------------------------    public Object add(Object key, Object value)	{		// assumes key and value are not null		Object oldValue; // value to returnw				if (isHashTableTooFull())			rehash();		int index = getHashIndex(key);		index = probe(index, key); // check for and resolve collision		// Assertion: index is in legal range for hashTable				if (hashTable[index] == null || hashTable[index].isRemoved())		{			// key not found, so insert new entry						hashTable[index] = new TableEntry(key, value);			currentSize++;			oldValue = null;		}		else		{			// key found; get old value for return and then replace it						oldValue = hashTable[index].getValue(); // get old value for return			hashTable[index].setValue(value);  		 // replace value		} // end if		return oldValue;	} // end add    public Object remove(Object key)	{   	Object result = null;   			int index = getHashIndex(key);		index = probe(index, key);				if ((hashTable[index] != null) && (hashTable[index].isIn()))		{			// key found; flag entry as removed and return its value			hashTable[index].setToRemoved();			// flag entry removed			result = hashTable[index].getValue();  // get old value for return			currentSize--;		} // end if		// else not found; result is null				return result;   } // end remove   public Object getValue(Object key)   {   	Object result = null;   			int index = getHashIndex(key);		index = probe(index, key);		if ((hashTable[index] != null) && (hashTable[index].isIn()))		{			// key found; get value			result = hashTable[index].getValue(); 		}		// else not found; result is null				return result;   } // end getValue//-------------------------------------------------// one version for all 3 methods; requires calling method to check for null, inactive, or active	private int probe(int index, Object key)	{		boolean found = false;		boolean repeatedIndex = false;		// loop must ignore removed entries (ie, not null but not occupied)		// loop ends at key found or null		// index always in range due to mod of probe seq		int increment = 1; // for quadratic probing				int firstIndex = index;		int notInUseIndex = -1; // index of first location not occupied, but not null		while ( !found && !repeatedIndex && (hashTable[index] != null) )		{			// skip entries that are not used [were removed]			if ( hashTable[index].isRemoved() )			{				// save index to first not-in-use location found				if (notInUseIndex == -1)					notInUseIndex = index;// want the first one to keep it close to probe seq				index = (index + 1) % hashTable.length; 			// linear probing			}			else if (key.equals(hashTable[index].getKey()) )				found = true; // key found						else // follow probe sequence				index = (index + 1) % hashTable.length; 			// linear probing			if (index == firstIndex)				repeatedIndex = true; // probe sequence is repeating		} // end while		if (found || (notInUseIndex == -1) ) 			return index;		else 			return notInUseIndex;	} // end probe		public boolean contains(Object key)    {   		return getValue(key) != null;     } // end contains    public boolean isEmpty()    {      	return currentSize == 0;    } // end isEmpty	    public boolean isFull()    {      	return false;    } // end isFull	public int getSize()	{	  return currentSize;	} // end getSize	public final void clear()	{ 	  currentSize = 0;	} // end clear	private int getHashIndex(Object key)	{		int hashIndex = key.hashCode() % hashTable.length; 				if (hashIndex < 0)		{			hashIndex = hashIndex + hashTable.length;		} // end if			//System.out.println("hash index is " + hashIndex);///		return hashIndex;	} // end getHashIndex	   // Purpose: Increase the size of the hash table to a prime > twice its old size.	private void rehash()	{ 	   TableEntry[] oldTable = hashTable; 	   int oldSize = hashTable.length;     	   int newSize = getNextPrime(oldSize + oldSize);				// System.out.println(" Rehashing to new size " + newSize + "****");///	   	   hashTable = new TableEntry[newSize];    // increase size of array	   	   // reset size of dictionary, since we use add to rehash (so currentSize is incremented)	   currentSize = 0; 	   	   // rehash dictionary entries from old array to new, bigger array.	   // skip null locations and not-in-use entries	   for (int index = 0; index < oldSize; ++index)	   {	   	if ( (oldTable[index] != null) && oldTable[index].isIn() )	   	{	   		add(oldTable[index].getKey(), oldTable[index].getValue());	   	} // end if	   } // end for	} // end rehash   private boolean isHashTableTooFull()   {      return currentSize >= MAX_LOAD_FACTOR * hashTable.length;   } // end isHashTableTooFull	private int getNextPrime(int integer)	{		// if even, add 1 to make odd		if (integer % 2 == 0)			integer++;		// test odd integers		while(!isPrime(integer))			integer = integer + 2;		return integer;	} // end getNextPrime		private boolean isPrime(int integer)	{		boolean result;		boolean done = false;				// 2 and 3 are prime		if ( (integer == 2) || (integer == 3) )		{			result = true;		}				// 1 and even numbers are not prime		else if ( (integer == 1) || (integer % 2 == 0) )	  	{			result = false; 		}				// Assertion: integer is odd and >= 5.		else		{			// a prime is odd and not divisible by every odd integer up to its square root			result = true; // assume prime			for (int divisor = 3; !done && (divisor * divisor <= integer); divisor = divisor + 2)			{		   	if (integer % divisor == 0)	      	{					result = false; // divisible; not prime					done = true;				} // end if			} // end for		} // end if	   			return result;	} // end isPrime	public Iterator getKeyIterator()	{ 		return new KeyIterator();	} // end getKeyIterator		public Iterator getValueIterator()	{			return new ValueIterator();	} // end getValueIterator	private class KeyIterator implements Iterator	{		private int currentIndex;		private int numberLeft; 				private KeyIterator() 		{			currentIndex = 0;			numberLeft = currentSize; //ok		} // end default constructor				public boolean hasNext() 		{			return numberLeft > 0; 		} // end hasNext				public Object next()		{			Object result = null;						if (hasNext())			{				while ( (hashTable[currentIndex] == null) || hashTable[currentIndex].isRemoved() ) 				{					currentIndex++;				} // end while								result = hashTable[currentIndex].getKey();				numberLeft--;				currentIndex++;			}			else			{				throw new NoSuchElementException();			}					return result;		} // end next				public void remove()		{			//throw new UnsupportedOperationException();		} // end remove	} // end KeyIterator		private class ValueIterator implements Iterator	{		private int currentIndex;		private int numberLeft; 				private ValueIterator() 		{			currentIndex = 0;			numberLeft = currentSize;		} // end default constructor				public boolean hasNext() 		{			return numberLeft > 0; 		} // end hasNext				public Object next()		{			Object result = null;						if (hasNext())			{				while ( (currentIndex < hashTable.length) && 				        ( (hashTable[currentIndex] == null) || hashTable[currentIndex].isRemoved() ) )				{					currentIndex++;				} // end while								result = hashTable[currentIndex].getValue();				numberLeft--;				currentIndex++;			}			else			{				throw new NoSuchElementException();			}					return result;		} // end next				public void remove()		{			throw new UnsupportedOperationException();		} // end remove	} // end ValueIterator	private class TableEntry implements java.io.Serializable	{		private Object entryKey;		private Object entryValue;		private boolean inTable; // true if entry is in table, false if entry was removed				private TableEntry(Object key, Object value)		{			entryKey = key;			entryValue = value;			inTable = true;		} // end constructor				public Object getKey()		{			return entryKey;		} // end getKey				public Object getValue()		{			return entryValue;		} // end getValue				public void setValue(Object newValue)		{			entryValue = newValue;		} // end setValue		public boolean isIn()		{			return inTable;		} // end isIn				public boolean isRemoved() // opposite of contains		{			return !inTable;		} // end isRemoved		// state = true means entry in use; false means entry not in use, ie deleted		public void setToRemoved()		{			inTable = false;		} // end setToRemoved				public void setToIn() // not used		{			inTable = true;		} // end setToIn				public boolean equals(Object other)		{			return inTable && ((TableEntry)other).entryKey.equals(this.entryKey) && 			                  ((TableEntry)other).entryValue.equals(this.entryValue);			                  		} // end equals	} // end TableEntry} // end HashedDictionary