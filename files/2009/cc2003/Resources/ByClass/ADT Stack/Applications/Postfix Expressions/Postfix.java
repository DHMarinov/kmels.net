// Segments 20.18 and 20.20public class Postfix {	/** Task: Creates a postfix expression that represents a given infix 	 *        expression.	 *  @param infix  a string that is a valid infix expression	 *  @return a string that is the postfix expression equivalent of 	 *          infix */	public static String convertToPostfix(String infix)	{		StringBuffer postfix = new StringBuffer();		StackInterface operatorStack = new LinkedStack();		int characterCount = infix.length();		Character top;		char topOperator;		for (int index = 0; index < characterCount; index++)		{			boolean done = false;			char nextCharacter = infix.charAt(index);			if (isVariable(nextCharacter))				postfix = postfix.append(nextCharacter);			else			{				switch (nextCharacter)				{					case '^':						operatorStack.push(new Character(nextCharacter));						break;					case '+': case '-': case '*': case '/':						while (!done && !operatorStack.isEmpty())						{							top = (Character) operatorStack.peek();							topOperator = top.charValue();							if (getPrecedence(nextCharacter) <= 							    getPrecedence(topOperator))							{								postfix = postfix.append(topOperator);								operatorStack.pop();							} 							else								done = true;						} // end while						operatorStack.push(new Character(nextCharacter));						break;					case '(':						operatorStack.push(new Character(nextCharacter));						break;					case ')': // stack is not empty if infix expression is valid						top = (Character) operatorStack.pop();						topOperator = top.charValue();						while (topOperator != '(')						{							postfix = postfix.append(topOperator);							top = (Character) operatorStack.pop();							topOperator = top.charValue();						} // end while					break;					default: break;				} // end switch			} // end if		} // end for		while (!operatorStack.isEmpty())		{			top = (Character) operatorStack.pop();			postfix = postfix.append(top.charValue());		} // end while		return postfix.toString();	} // end convertToPostfix// STUDENT EXERCISE - based on pseudocode in Segment 20.20	public static double evaluatePostfix(String postfix)	{		StackInterface valueStack = new LinkedStack();		int characterCount = postfix.length();				for (int index = 0; index < characterCount; index++)		{			char nextCharacter = postfix.charAt(index);			if (isVariable(nextCharacter))				valueStack.push(new Double(valueOf(nextCharacter)));			else			{				switch (nextCharacter)				{					case '+': case '-': case '*': case '/': case '^':						Double operandTwo = (Double) valueStack.pop();						Double operandOne = (Double) valueStack.pop();						Double result = compute(operandOne, operandTwo, nextCharacter);						valueStack.push(result);						break;											default: break;				} // end switch			} // end if		} // end for				return ((Double) valueStack.peek()).doubleValue();	} // end evaluatePostfix	/** Task: Determines the precedence of a given operator.	 *  @param operator  a character that is (, ), +, -, *, /, or ^	 *  @return an integer that indicates the precedence of operator: 	 *          0 if ( or ), 1 if + or -, 2 if * or /, 3 if ^, -1 if 	 *          anything else */	private static int getPrecedence(char operator)	{		switch (operator)		{			case '(': case ')': return 0;			case '+': case '-': return 1;			case '*': case '/': return 2;			case '^':           return 3;		} // end switch		return -1;	} // end getPrecedence	private static boolean isVariable(char character)	{		return Character.isLetter(character);	} // end isVariable		private static double valueOf(char variable)	{		switch (variable)		{			case 'a': return 2.0;			case 'b': return 3.0;			case 'c': return 4.0;			case 'd': return 5.0;		} // end switch				return 0;	} // end valueOf		private static Double compute(Double operandOne, Double operandTwo, char operator)	{		double result;				switch (operator)		{			case '+': 				result = operandOne.doubleValue() + operandTwo.doubleValue();				break;							case '-': 				result = operandOne.doubleValue() - operandTwo.doubleValue();				break;			case '*':				result = operandOne.doubleValue() * operandTwo.doubleValue();				 break;			case '/': 				result = operandOne.doubleValue() / operandTwo.doubleValue();				break;			case '^': 				result = Math.pow(operandOne.doubleValue(), operandTwo.doubleValue());				break;							default: 				result = 0;				break;		} // end switch			return new Double(result);	} // end compute} // end Postfix