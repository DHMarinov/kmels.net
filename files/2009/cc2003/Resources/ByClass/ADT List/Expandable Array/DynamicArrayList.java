public class DynamicArrayList implements ListInterface{	private Object[] entry; // array of list entries	private int length;     // current number of entries in list	private static final int INITIAL_SIZE = 50; // max length of list 	public DynamicArrayList()	{		length = 0;		entry = new Object[INITIAL_SIZE];	} // end default constructor	public DynamicArrayList(int initialSize)	{		length = 0;		entry = new Object[initialSize];	} // end constructor	public boolean add(Object newEntry)	{		if (isArrayFull()) 			doubleArray();		// add new entry after last current entry		entry[length] = newEntry;		length++;		return true;	} // end add		//  STUDENT EXCERCISE	public boolean add(int newPosition, Object newEntry)	{		boolean isSuccessful = true;		if ((newPosition >= 1) && (newPosition <= length+1)) 		{				if (isArrayFull()) 				doubleArray();							makeRoom(newPosition);							entry[newPosition-1] = newEntry;			length++;		}		else			isSuccessful = false;					return isSuccessful;	} // end add	public Object remove(int givenPosition) 	{		Object result = null;  // return value		if ((givenPosition >= 1) && (givenPosition <= length))		{			result = entry[givenPosition-1]; // get entry to be removed			// move subsequent entries toward entry to be removed, 			// unless it is last in list			if (givenPosition < length)				removeGap(givenPosition);			length--;		} // end if		return result;  // return reference to removed entry,		                // or null if givenPosition is invalid	} // end remove	public void clear()	{		length = 0;	} // end clear	public boolean replace(int givenPosition, Object newEntry)	{		boolean isSuccessful = true;		if ((givenPosition >= 1) && (givenPosition <= length))			entry[givenPosition-1] = newEntry;		else			isSuccessful = false;		return isSuccessful;	} // end replace	public Object getEntry(int givenPosition)	{		Object result = null;  // result to return		if ((givenPosition >= 1) && (givenPosition <= length))			result = entry[givenPosition-1];		return result;	} // end getEntry	public boolean contains(Object anEntry)	{		boolean found = false;		for (int index = 0; !found && (index < length); index++)		{			if (anEntry.equals(entry[index]))				found = true;		} // end for		return found;	} // end contains	public int getLength()	{		return length;	} // end getLength	public boolean isEmpty()	{		return length == 0;	} // end isEmpty	public boolean isFull()	{		return false;	} // end isFull	public void display()	{		for (int index = 0; index < length; index++)			System.out.println(entry[index]);	} // end display		private boolean isArrayFull()	// Returns true if the array of list entries is full,	{	  return length == entry.length;	} // end isArrayFull		/** Task: Doubles the size of the array of list entries. */	private void doubleArray()	{		Object[] oldList = entry;      // save reference to array of 		                               // list entries		int oldSize = oldList.length;  // save old max size of array		entry = new Object[2*oldSize]; // double size of array		// copy entries from old array to new, bigger array		for (int index = 0; index < oldSize; index++)			entry[index] = oldList[index];	} // end doubleArray	private void makeRoom(int newPosition)	{		// move each entry to next higher position, starting at end of		// list and continuing until the entry at newPosition is moved		for (int index = length; index >= newPosition; index--)			entry[index] = entry[index-1];	} // end makeRoom		/** Task: Shifts entries that are beyond the entry to be removed 	 *        to next lower position.	 *  Precondition: 1 <= givenPosition <= length;	 *                length is listâs length before removal. */	private void removeGap(int givenPosition)	{		for (int index = givenPosition; index < length; index++)			entry[index-1] = entry[index];	} // end removeGap} // end DynamicArrayList