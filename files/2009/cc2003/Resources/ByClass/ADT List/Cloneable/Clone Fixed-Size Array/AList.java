public class AList implements ListInterface, Cloneable{	private Listable[] entry; // array of list entries	private int length;       // current number of entries in list	private static final int MAX_SIZE = 50; // max length of list	public AList()	{		length = 0;		entry = new Listable[MAX_SIZE];	} // end default constructor	public AList(int maxSize)	{		length = 0;		entry =  new Listable[maxSize];	} // end constructor	public Object clone()	{		AList theCopy = null;		try		{			theCopy = (AList)super.clone(); // not enough by itself		}		catch (CloneNotSupportedException e)		{			throw new Error(e.toString());		} // end try-catch		theCopy.entry = (Listable[])entry.clone();		for (int index = 0; index < length; index++)			theCopy.entry[index] = (Listable)entry[index].clone();		return theCopy;	} // end clone	public boolean add(Listable newEntry)	{		boolean isSuccessful = true;		if (!isFull()) 		{			// position of new entry will be after last entry in list,			// that is, at position length+1; corresponding array index is			// 1 less than position, so index is length			entry[length] = newEntry;			length++;		}		else			isSuccessful = false;		return isSuccessful;	} // end add	public boolean add(int newPosition, Listable newEntry)	{		boolean isSuccessful = true;		if (!isFull() && (newPosition >= 1) 		              && (newPosition <= length+1)) 		{			makeRoom(newPosition);			entry[newPosition-1] = (Listable)newEntry;			length++;		}		else			isSuccessful = false;		return isSuccessful;	} // end add	public Listable remove(int givenPosition) 	{		Listable result = null;  // return value		if ((givenPosition >= 1) && (givenPosition <= length))		{			result = entry[givenPosition-1]; // get entry to be removed			// move subsequent entries toward entry to be removed, 			// unless it is last in list			if (givenPosition < length)				removeGap(givenPosition);			length--;		} // end if		return result;  // return reference to removed entry,	            	    // or null if givenPosition is invalid	} // end remove	public void clear()	{		length = 0;		entry = new Listable[MAX_SIZE];	} // end clear	public boolean replace(int givenPosition, Listable newEntry)	{		boolean isSuccessful = true;		if ((givenPosition >= 1) && (givenPosition <= length))			entry[givenPosition-1] = newEntry;		else			isSuccessful = false;		return isSuccessful;	} // end replace	public Listable getEntry(int givenPosition)	{		Listable result = null;  // result to return		if ((givenPosition >= 1) && (givenPosition <= length))			result = entry[givenPosition-1];		return result;	} // end getEntry	public boolean contains(Listable anEntry)	{		boolean found = false;		for (int index = 0; !found && (index < length); index++)		{			if (anEntry.equals(entry[index]))				found = true;		} // end for		return found;	} // end contains		public int getLength()	{		return length;	} // end getLength	public boolean isEmpty()	{		return length == 0;	} // end isEmpty	public boolean isFull()	{		return length == entry.length;	} // end isFull	public void display()	{		for (int index = 0; index < length; index++)			System.out.println(entry[index]);	} // end display	private void makeRoom(int newPosition)	{		// move each entry to next higher position, starting at end of		// list and continuing until the entry at newPosition is moved		for (int index = length; index >= newPosition; index--)			entry[index] = entry[index-1];	} // end makeRoom	private void removeGap(int givenPosition)	{		// shifts entries that are beyond the entry to be removed 		// to next lower position.		for (int index = givenPosition; index < length; index++)			entry[index-1] = entry[index];	} // end removeGap} // end AList