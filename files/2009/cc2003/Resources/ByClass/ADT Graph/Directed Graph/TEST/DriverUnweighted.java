/* Unweighted directed graph   This program uses the same graph files as the weighted    version, but creates an unweighted graph in main */import java.io.*;import java.util.*;public class DriverUnweighted {	private static DirectedGraph myGraph = new DirectedGraph();	private static Name A = new Name("A");	private static Name B = new Name("B");	private static Name C = new Name("C");	private static Name D = new Name("D");	private static Name E = new Name("E");	private static Name F = new Name("F");	private static Name G = new Name("G");	private static Name H = new Name("H");	private static Name I = new Name("I");  	private static Name cs1 = new Name("cs1");	private static Name cs2 = new Name("cs2");	private static Name cs3 = new Name("cs3");	private static Name cs4 = new Name("cs4");	private static Name cs5 = new Name("cs5");	private static Name cs6 = new Name("cs6");	private static Name cs7 = new Name("cs7");	private static Name cs8 = new Name("cs8");	private static Name cs9 = new Name("cs9");	private static Name cs10 = new Name("cs10");	public static void main(String[] args)	{ 		testHasEdge();		test_bfs(A); // A B D E G F H C I 		test_dfs(A); // A B E F C H I D G  				testTopSort(); // cs1   cs2   cs4   cs7   cs9   cs6   cs8   cs5   cs3   cs10   		testShortestPath();		System.out.println("Done");	}  // end main		public static void testHasEdge()	{		setVerticesFig2910(); // graph cleared in setVertices		setEdgesFig2910();			// check existing edges			 	if (!myGraph.hasEdge(A, B))				System.out.println("hasEdge error " + A + " " + B);	 	if (!myGraph.hasEdge(E, F))				System.out.println("hasEdge error " + E + " " + F);			 	if (!myGraph.hasEdge(F, C))				System.out.println("hasEdge error " + F + " " + C);	 	if (!myGraph.hasEdge(H, I))				System.out.println("hasEdge error " + H + " " + I);	// check non-existing edges			 	if (myGraph.hasEdge(A, I))				System.out.println("hasEdge error " + A + " " + I);	 	if (myGraph.hasEdge(C, E))				System.out.println("hasEdge error " + C + " " + E);	} // end testHasEdge	public static void test_bfs(Object v)	{		setVerticesFig2910(); // graph cleared in setVertices		setEdgesFig2910();			System.out.println("\nTesting Breadth-First Traversal:\n");		myGraph.display();				System.out.print("\n\nBreadth-First Traversal: ");		QueueInterface bfs = myGraph.getBreadthFirstTraversal(v);				printQueue(bfs);	} // end test_bfs		public static void test_dfs(Object v)	{		setVerticesFig2910(); // graph cleared in setVertices		setEdgesFig2910();			System.out.println("\nTesting Depth-First Traversal:\n");		myGraph.display();				System.out.println("\n\nDepth-First Traversal: ");		QueueInterface dfs = myGraph.getDepthFirstTraversal(v);				printQueue(dfs);	} // end test_dfs		public static void setVerticesFig2910()	{				myGraph.clear();		myGraph.addVertex(A);		myGraph.addVertex(B);		myGraph.addVertex(C);		myGraph.addVertex(D);		myGraph.addVertex(E);		myGraph.addVertex(F);		myGraph.addVertex(G);		myGraph.addVertex(H);		myGraph.addVertex(I);	} // end setVerticesFig2910		public static void setEdgesFig2910()	{		myGraph.addEdge(A, B);		myGraph.addEdge(A, D);		myGraph.addEdge(A, E);				myGraph.addEdge(B, E);				myGraph.addEdge(C, B);				myGraph.addEdge(D, G);		myGraph.addEdge(E, F);		myGraph.addEdge(E, H);				myGraph.addEdge(F, C);		myGraph.addEdge(F, H);				myGraph.addEdge(G, H);				myGraph.addEdge(H, I);		myGraph.addEdge(I, F);	} // end setEdgesFig2910	public static void setVerticesFig2908()	{				myGraph.clear();		myGraph.addVertex(cs1);		myGraph.addVertex(cs2);		myGraph.addVertex(cs3);		myGraph.addVertex(cs4);		myGraph.addVertex(cs5);		myGraph.addVertex(cs6);		myGraph.addVertex(cs7);		myGraph.addVertex(cs8);		myGraph.addVertex(cs9);		myGraph.addVertex(cs10);	} // end setVerticesFig2908		public static void setEdgesFig2908()	{		myGraph.addEdge(cs1, cs2);				myGraph.addEdge(cs2, cs3);		myGraph.addEdge(cs2, cs4);		myGraph.addEdge(cs2, cs5);				myGraph.addEdge(cs4, cs6);		myGraph.addEdge(cs4, cs7);				myGraph.addEdge(cs5, cs10);		myGraph.addEdge(cs6, cs8);		myGraph.addEdge(cs7, cs8);		myGraph.addEdge(cs7, cs9);				myGraph.addEdge(cs9, cs10);	} // end setEdgesFig2908	public static void testTopSort()	{		setVerticesFig2908(); // graph cleared in setVertices		setEdgesFig2908();					System.out.println("\nTesting Depth-First Traversal:\n");		myGraph.display();				System.out.println("\n\nTopological order: ");		StackInterface sort = myGraph.getTopologicalSort();				printStack(sort);	} // end testTopSort		public static void testShortestPath()	// UNWEIGHTED graph in Figure 29-15a (same as Fig. 29-10)	{		StackInterface path = null;		setVerticesFig2910(); // graph cleared in setVertices		setEdgesFig2910();			System.out.println("\nTesting Shortest Path Algorithm:\n");		myGraph.display();				System.out.println("\n\nShortest path: " + A + " to " + B);		path = myGraph.getShortestPath(A, B);		printStack(path);		System.out.println("Shortest path: " + A + " to " + C);		path = myGraph.getShortestPath(A, C);		printStack(path);			System.out.println("Shortest path: " + A + " to " + D);		path = myGraph.getShortestPath(A, D);		printStack(path);			System.out.println("Shortest path: " + A + " to " + E);		path = myGraph.getShortestPath(A, E);		printStack(path);		System.out.println("Shortest path: " + A + " to " + F);		path = myGraph.getShortestPath(A, F);		printStack(path);		System.out.println("Shortest path: " + A + " to " + G);		path = myGraph.getShortestPath(A, G);		printStack(path);		System.out.println("Shortest path: " + A + " to " + H);		path = myGraph.getShortestPath(A, H);		printStack(path);		System.out.println("Shortest path: " + A + " to " + I);		path = myGraph.getShortestPath(A, I);		printStack(path);	} // end testShortestPath	public static void printStack(StackInterface s)	{		while (!s.isEmpty())			System.out.print(s.pop() + " ");		System.out.println();		System.out.println();	} // end printStack		public static void printQueue(QueueInterface q)	{		while (!q.isEmpty())			System.out.print(q.dequeue() + " ");		System.out.println();		System.out.println();	} // end printQueue}  // end DriverUnweighted