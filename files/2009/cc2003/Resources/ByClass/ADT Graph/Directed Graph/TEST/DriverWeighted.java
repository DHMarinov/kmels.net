/* Weighted directed graph   This program uses the same graph files as the Unweighted    version, but creates a weighted graph in main */   import java.io.*;import java.util.*;public class DriverWeighted {	private static DirectedGraph myGraph = new DirectedGraph();	private static Name A = new Name("A");	private static Name B = new Name("B");	private static Name C = new Name("C");	private static Name D = new Name("D");	private static Name E = new Name("E");	private static Name F = new Name("F");	private static Name G = new Name("G");	private static Name H = new Name("H");	private static Name I = new Name("I");		public static void main(String[] argv)	{ 		testWeights(); 		testCheapestPath(); 		System.out.println("Done");	}  // end main		public static void testWeights() 	{		setVerticesFig2918a();		setEdgesFig2918a();			System.out.println("Looking at weights:");		myGraph.display();		} // end testWeights	public static void testCheapestPath()	// WEIGHTED graph in Figure 29-18a	{		StackInterface path = null;				setVerticesFig2918a();		setEdgesFig2918a();			System.out.println("Vertices in graph:");		myGraph.display();				System.out.println("Cheapest path: " + A + " to " + B);		path = myGraph.getCheapestPath(A, B);		printStack(path);		myGraph.resetVertices();		System.out.println("Cheapest path: " + A + " to " + C);		path = myGraph.getCheapestPath(A, C);		printStack(path);		   myGraph.resetVertices();		System.out.println("Cheapest path: " + A + " to " + D);		path = myGraph.getCheapestPath(A, D);		printStack(path);			myGraph.resetVertices();		System.out.println("Cheapest path: " + A + " to " + E);		path = myGraph.getCheapestPath(A, E);		printStack(path);		myGraph.resetVertices();		System.out.println("Cheapest path: " + A + " to " + F);		path = myGraph.getCheapestPath(A, F);		printStack(path);		myGraph.resetVertices();		System.out.println("Cheapest path: " + A + " to " + G);		path = myGraph.getCheapestPath(A, G);		printStack(path);		myGraph.resetVertices();		System.out.println("Cheapest path: " + A + " to " + H);		path = myGraph.getCheapestPath(A, H);		printStack(path);		myGraph.resetVertices();		System.out.println("Cheapest path: " + A + " to " + I);		path = myGraph.getCheapestPath(A, I);		printStack(path);	} // end testCheapestPath	public static void setVerticesFig2918a()	{		myGraph.clear();		myGraph.addVertex(A);		myGraph.addVertex(B);		myGraph.addVertex(C);		myGraph.addVertex(D);		myGraph.addVertex(E);		myGraph.addVertex(F);		myGraph.addVertex(G);		myGraph.addVertex(H);		myGraph.addVertex(I);	} // end setVertices	public static void setEdgesFig2918a()	{		myGraph.addEdge(A, B, 2);		myGraph.addEdge(A, D, 5);		myGraph.addEdge(A, E, 4);				myGraph.addEdge(B, E, 1);				myGraph.addEdge(C, B, 3);				myGraph.addEdge(D, G, 2);		myGraph.addEdge(E, F, 3);		myGraph.addEdge(E, H, 6);				myGraph.addEdge(F, C, 4);		myGraph.addEdge(F, H, 3);				myGraph.addEdge(G, H, 1);				myGraph.addEdge(H, I, 1);		myGraph.addEdge(I, F, 1);	} // end setEdges	public static void printStack(StackInterface s)	{		Vertex top = null;		while (!s.isEmpty())		{			top = (Vertex)s.pop();			System.out.print(top + " ");		} // end while				System.out.println("Total cost of path is " + top.getCost());		System.out.println();		System.out.println();	} // end printStack		public static void printQueue(QueueInterface q)	{		while (!q.isEmpty())			System.out.print(q.dequeue() + " ");		System.out.println();		System.out.println();	} // end printQueue}  // end DriverWeighted	