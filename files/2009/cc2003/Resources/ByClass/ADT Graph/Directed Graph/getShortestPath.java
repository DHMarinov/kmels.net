public StackInterface getShortestPath(Object begin, Object end){	resetVertices();	boolean done = false;	QueueInterface vertexQueue = new LinkedQueue();	Vertex originVertex = (Vertex)vertices.getValue(begin);	Vertex endVertex = (Vertex)vertices.getValue(end);	originVertex.visit();		// Assertion: resetVertices() has executed setCost(0)	// and setPredecessor(null) for originVertex	vertexQueue.enqueue(originVertex);	while (!done && !vertexQueue.isEmpty())	{		Vertex frontVertex = (Vertex)vertexQueue.dequeue();		Iterator edges = frontVertex.getNeighborIterator();		while (!done && edges.hasNext())		{			Edge edgeToNextNeighbor = (Edge)edges.next();			Vertex nextNeighbor = edgeToNextNeighbor.getEndVertex();			if (!nextNeighbor.isVisited())			{				nextNeighbor.visit();				nextNeighbor.setCost(1 + frontVertex.getCost());				nextNeighbor.setPredecessor(frontVertex);				vertexQueue.enqueue(nextNeighbor);			} // end if						if (nextNeighbor.equals(endVertex))				done = true;		} // end while	} // end while	// traversal ends; construct shortest path	StackInterface path = new LinkedStack();	path.push(endVertex);	while (endVertex.hasPredecessor())	{		endVertex = endVertex.getPredecessor();		path.push(endVertex);	} // end while		return path;} // end getShortestPath