package GraphPackage;import java.util.Iterator;public class DirectedGraph implements GraphInterface, java.io.Serializable{	private DictionaryInterface vertices;	private int edgeCount;		public DirectedGraph()	{		vertices = new SortedLinkedDictionary();		edgeCount = 0;	} // end default constructor		public void addVertex(Object vertexLabel)	{		vertices.add(vertexLabel, new Vertex(vertexLabel));	} // end addVertex		public void addEdge(Object begin, Object end)	{		addEdge(begin, end, 0);	} // end addEdge		public void addEdge(Object begin, Object end, double edgeWeight)	{		Vertex beginVertex = (Vertex)vertices.getValue(begin);		Vertex endVertex = (Vertex)vertices.getValue(end);		beginVertex.addEdge(endVertex, edgeWeight);		edgeCount++;	} // end addEdge		public boolean hasEdge(Object begin, Object end)	{		boolean found = false;		Vertex beginVertex = (Vertex)vertices.getValue(begin);		Vertex endVertex = (Vertex)vertices.getValue(end);		Iterator edges = beginVertex.getNeighborIterator();		while (!found && edges.hasNext())		{			Edge nextEdge = (Edge)(edges.next());			if (endVertex.equals(nextEdge.getEndVertex()))				found = true;		} // end while				return found;	} // end hasEdge	public boolean isEmpty()	{		return vertices.isEmpty();	} // end isEmpty	public int getNumberOfVertices()	{		return vertices.getSize();	} // end getNumberOfVertices	public int getNumberOfEdges()	{		return edgeCount;	} // end getNumberOfEdges	public void clear()	{		vertices.clear();		edgeCount = 0;	} // end clear	protected void resetVertices()	{		Iterator vertexIterator = vertices.getValueIterator();		while (vertexIterator.hasNext())		{			Vertex nextVertex = (Vertex)vertexIterator.next();			nextVertex.unVisit();			nextVertex.setCost(0);			nextVertex.setPredecessor(null);		} // end while	} // end resetVertices	public QueueInterface getDepthFirstTraversal(Object origin)	{		// assumes graph is not empty		resetVertices();		QueueInterface traversalOrder = new LinkedQueue();				StackInterface vertexStack = new LinkedStack();				Vertex originVertex = (Vertex)vertices.getValue(origin);		originVertex.visit();		traversalOrder.enqueue(originVertex);		vertexStack.push(originVertex);			while (!vertexStack.isEmpty())		{			Vertex topVertex = (Vertex)vertexStack.peek();			Iterator edges = topVertex.getNeighborIterator();						// look for unvisited neighbor			Vertex nextNeighbor = null;			boolean found = false;			while (!found && edges.hasNext())			{				Edge edgeToNextNeighbor = (Edge)edges.next();				nextNeighbor = edgeToNextNeighbor.getEndVertex();							if (!nextNeighbor.isVisited())					found = true;			} // end while						if (!found)				vertexStack.pop(); // all neighbors are visited							else 	// nextNeighbor was unvisited 			{				nextNeighbor.visit();				traversalOrder.enqueue(nextNeighbor);				vertexStack.push(nextNeighbor);			}		} // end while				return traversalOrder;	} // end getDepthFirstTraversal		public QueueInterface getBreadthFirstTraversal(Object origin)	{		resetVertices();		QueueInterface vertexQueue = new LinkedQueue();		QueueInterface traversalOrder = new LinkedQueue();		Vertex originVertex = (Vertex)vertices.getValue(origin);		originVertex.visit();		traversalOrder.enqueue(originVertex);		vertexQueue.enqueue(originVertex);				while (!vertexQueue.isEmpty())		{			Vertex frontVertex = (Vertex)vertexQueue.dequeue();			Iterator edges = frontVertex.getNeighborIterator();			while (edges.hasNext())			{				Edge edgeToNextNeighbor = (Edge)edges.next();				Vertex nextNeighbor = edgeToNextNeighbor.getEndVertex();				if (!nextNeighbor.isVisited())				{					nextNeighbor.visit();					traversalOrder.enqueue(nextNeighbor);					vertexQueue.enqueue(nextNeighbor);				} // end if			} // end while		} // end while				return traversalOrder;	} // end getBreadthFirstTraversal	public StackInterface getTopologicalSort() 	{		resetVertices();		StackInterface stack = new LinkedStack();		int n = getNumberOfVertices();		for (int counter = 1; counter <= n; counter++)		{			Vertex nextVertex = findTerminal();			nextVertex.visit();			stack.push(nextVertex);		} // end for				return stack;		} // end getTopologicalSort	public StackInterface getShortestPath(Object begin, Object end)	{		resetVertices();		boolean done = false;		QueueInterface vertexQueue = new LinkedQueue();		Vertex originVertex = (Vertex)vertices.getValue(begin);		Vertex endVertex = (Vertex)vertices.getValue(end);		originVertex.visit();				// Assertion: resetVertices() has executed setCost(0)		// and setPredecessor(null) for originVertex		vertexQueue.enqueue(originVertex);		while (!done && !vertexQueue.isEmpty())		{			Vertex frontVertex = (Vertex)vertexQueue.dequeue();			Iterator edges = frontVertex.getNeighborIterator();			while (!done && edges.hasNext())			{				Edge edgeToNextNeighbor = (Edge)edges.next();				Vertex nextNeighbor = edgeToNextNeighbor.getEndVertex();				if (!nextNeighbor.isVisited())				{					nextNeighbor.visit();					nextNeighbor.setCost(1 + frontVertex.getCost());					nextNeighbor.setPredecessor(frontVertex);					vertexQueue.enqueue(nextNeighbor);				} // end if								if (nextNeighbor.equals(endVertex))					done = true;			} // end while		} // end while		// traversal ends; construct shortest path		StackInterface path = new LinkedStack();		path.push(endVertex);		while (endVertex.hasPredecessor())		{			endVertex = endVertex.getPredecessor();			path.push(endVertex);		} // end while				return path;	} // end getShortestPath	public StackInterface getCheapestPath(Object begin, Object end) // STUDENT EXERCISE	{		resetVertices();		boolean done = false;		PriorityQueueInterface vertexQueue = new PriorityQueue();				Vertex originVertex = (Vertex)vertices.getValue(begin);		Vertex endVertex = (Vertex)vertices.getValue(end);		vertexQueue.add(new PathEntry(originVertex, 0, null));			while (!done && !vertexQueue.isEmpty())		{			PathEntry frontEntry = (PathEntry)vertexQueue.remove();			Vertex frontVertex = frontEntry.getVertex();						if (!frontVertex.isVisited())			{				frontVertex.visit();				frontVertex.setCost(frontEntry.getCost());				frontVertex.setPredecessor(frontEntry.getPredecessor());								if (frontVertex.equals(endVertex))					done = true;				else 				{					Iterator edges = frontVertex.getNeighborIterator();					while (edges.hasNext())					{						Edge edgeToNextNeighbor = (Edge)edges.next();						Vertex nextNeighbor = edgeToNextNeighbor.getEndVertex();												if (!nextNeighbor.isVisited())						{							double edgeWeight = edgeToNextNeighbor.getWeight();							double nextCost = frontVertex.getCost() + edgeWeight;							vertexQueue.add(new PathEntry(nextNeighbor, nextCost, frontVertex));						} // end if					} // end while				} // end if			} // end if		} // end while		// traversal ends, construct cheapest path		StackInterface path = new LinkedStack();		path.push(endVertex);				while (endVertex.hasPredecessor())		{			endVertex = endVertex.getPredecessor();			path.push(endVertex);		} // end while		return path;	} // end getCheapestPath	private Vertex findTerminal()	{		boolean found = false;		Vertex result = null;		Iterator vertexIterator = vertices.getValueIterator();		while (!found && vertexIterator.hasNext())		{			Vertex nextVertex = (Vertex)vertexIterator.next();						// if nextVertex is unvisited AND has only visited nhbrs)						if (!nextVertex.isVisited())			{ 				if (nextVertex.getUnvisitedNeighbor() == null )				{ 					found = true;					result = nextVertex;				} // end if			} // end if		} // end while		return result;	} // end findTerminal	// Used for testing	public void display()	{		System.out.print("Graph with " + getNumberOfVertices() + " vertices and ");		System.out.println(getNumberOfEdges() + " edges.");				System.out.println("\n\nEdges exist from the first vertex in each line to the other vertices in the line.");		System.out.println("(Edge weights, if any, are given):\n");		Iterator vertexIterator = vertices.getValueIterator();		while (vertexIterator.hasNext())		{			((Vertex)(vertexIterator.next())).display();		} // end while	} // end display } // end DirectedGraph