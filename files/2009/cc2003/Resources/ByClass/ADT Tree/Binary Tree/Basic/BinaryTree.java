import java.util.*;public class BinaryTree implements BinaryTreeInterface, java.io.Serializable{	private BinaryNode root;		public BinaryTree()	{		root = null;	} // end default constructor		public BinaryTree(Object rootData)	{		root = new BinaryNode(rootData);	} // end constructor		public BinaryTree(Object rootData, BinaryTree leftTree,	                                   BinaryTree rightTree)	{		privateSetTree(rootData, leftTree, rightTree);	} // end constructor		public void setTree(Object rootData)	{		root = new BinaryNode(rootData);	} // end setTree		public void setTree(Object rootData, BinaryTreeInterface leftTree,	                                     BinaryTreeInterface rightTree)	{		privateSetTree(rootData, (BinaryTree)leftTree, (BinaryTree)rightTree);	} // end setTree	private void privateSetTree(Object rootData, 	                            BinaryTree leftTree, BinaryTree rightTree)	{		root = new BinaryNode(rootData);		if ((leftTree != null) && !leftTree.isEmpty())			root.setLeftChild(leftTree.root);		if ((rightTree != null) && !rightTree.isEmpty())		{			if (rightTree != leftTree)				root.setRightChild(rightTree.root);			else				root.setRightChild(rightTree.root.copy());		} // end if		if ((leftTree != null) && (this != leftTree))			leftTree.clear(); 		if ((rightTree != null) && (this != rightTree))			rightTree.clear();	} // end privateSetTree	public Object getRootData()	{		Object rootData = null;				if (root != null)		 	rootData =  root.getData();				return rootData;	} // end getRootData		protected void setRootData(Object rootData)	{		root.setData(rootData);	} // end setRootData		protected void setRootNode(BinaryNode rootNode)	{		root = rootNode;	} // end setRootNode	protected BinaryNode getRootNode()	{		return root;	} // end getRootNode	public int getHeight()	{		return root.getHeight();	} // end getHeight	public int getNumberOfNodes()	{		return root.getNumberOfNodes();	} // end getNumberOfNodes	public boolean isEmpty()	{		return root == null;	} // end isEmpty		public void clear()	{		root = null;	} // end clear	public Iterator getPreorderIterator()	{		return new PreorderIterator();	} // end getPreorderIterator	public Iterator getPostorderIterator()	{		return new PostorderIterator();	} // end getPostorderIterator	public Iterator getInorderIterator()	{		return new InorderIterator();	} // end getInorderIterator	public Iterator getLevelOrderIterator()	{		return new LevelOrderIterator();		} // end getLevelOrderIterator	private class PostorderIterator implements Iterator	{		private StackInterface nodeStack;		private BinaryNode currentNode;				public PostorderIterator()		{			nodeStack = new LinkedStack();			currentNode = root;		} // end default constructor				public boolean hasNext() 		{			return !nodeStack.isEmpty() || (currentNode != null);		} // end hasNext				public Object next()		{			boolean foundNext = false;			BinaryNode leftChild, rightChild, nextNode = null;						// find leftmost leaf			while (currentNode != null)			{				nodeStack.push(currentNode);				leftChild = (BinaryNode)currentNode.getLeftChild();				if (leftChild == null)						currentNode = (BinaryNode)currentNode.getRightChild();				else					currentNode = leftChild;			} // end while						// stack is not empty either because we just pushed a node, or			// it wasn't empty to begin with since hasNext() is true.			// But Iterator specifies an exception for next() in case			// hasNext() is false.						if (!nodeStack.isEmpty())			{				nextNode = (BinaryNode) nodeStack.pop();				// nextNode != null since stack was not empty before pop				BinaryNode parent = (BinaryNode) nodeStack.peek();								if (parent != null && nextNode == parent.getLeftChild())					currentNode = (BinaryNode)parent.getRightChild();					else					currentNode = null;			}			else			{				throw new NoSuchElementException();			} // end if						return nextNode.getData();		} // end next		public void remove()		{			throw new UnsupportedOperationException();		} // end remove	} // end PostorderIterator	private class PreorderIterator implements Iterator	{		private StackInterface nodeStack;				public PreorderIterator()		{			nodeStack = new LinkedStack();			if (root != null)				nodeStack.push(root);		} // end default constructor				public boolean hasNext() 		{			return !nodeStack.isEmpty();		} // end hasNext				public Object next()		{			BinaryNode nextNode;						if (hasNext())			{				nextNode = (BinaryNode) nodeStack.pop();				BinaryNode leftChild = (BinaryNode)nextNode.getLeftChild();				BinaryNode rightChild = (BinaryNode)nextNode.getRightChild();								// push into stack in reverse order of recursive calls				if (rightChild != null)					nodeStack.push(rightChild);									if (leftChild != null)					nodeStack.push(leftChild);			}			else			{				throw new NoSuchElementException();			}					return nextNode.getData();		} // end next			public void remove()		{			throw new UnsupportedOperationException();		} // end remove	} // end PreorderIterator	private class InorderIterator implements Iterator	{		private StackInterface nodeStack;		private BinaryNode     currentNode;		public InorderIterator()		{			nodeStack = new LinkedStack();			currentNode = root;		} // end default constructor		public boolean hasNext() 		{			return !nodeStack.isEmpty() || (currentNode != null);		} // end hasNext		public Object next()		{			BinaryNode nextNode = null;			while (currentNode != null)			{				nodeStack.push(currentNode);				currentNode = (BinaryNode)currentNode.getLeftChild();			} // end while			if (!nodeStack.isEmpty())			{				nextNode = (BinaryNode) nodeStack.pop();				currentNode = (BinaryNode)nextNode.getRightChild();			}			else				throw new NoSuchElementException();			return nextNode.getData(); 		} // end next		public void remove()		{			throw new UnsupportedOperationException();		} // end remove	} // end InorderIterator	private class LevelOrderIterator implements Iterator	{		private QueueInterface nodeQueue;				public LevelOrderIterator()		{			nodeQueue = new LinkedQueue();			if (root != null)				nodeQueue.enqueue(root);		} // end default constructor				public boolean hasNext() 		{			return !nodeQueue.isEmpty();		} // end hasNext				public Object next()		{			BinaryNode nextNode;						if (hasNext())			{				nextNode = (BinaryNode) nodeQueue.dequeue();				BinaryNode leftChild = (BinaryNode)nextNode.getLeftChild();				BinaryNode rightChild = (BinaryNode)nextNode.getRightChild();								// add to queue in order of recursive calls				if (leftChild != null)					nodeQueue.enqueue(leftChild);				if (rightChild != null)					nodeQueue.enqueue(rightChild);			}			else			{				throw new NoSuchElementException();			}					return nextNode.getData();		} // end next			public void remove()		{			throw new UnsupportedOperationException();		} // end remove	} // end LevelOrderIterator	} // end BinaryTree