// 27.4public class MaxHeap implements MaxHeapInterface, java.io.Serializable{	private Comparable[] heap;     // array of heap entries	private static final int DEFAULT_MAX_SIZE = 25;	private int	lastIndex; // index of last entry// 27.4	public MaxHeap()	{		heap = new Comparable[DEFAULT_MAX_SIZE];		lastIndex = 0;	} // end default constructor		public MaxHeap(int maxSize)	{		heap = new Comparable[maxSize];		lastIndex = 0;	} // end constructor// 27.15	public MaxHeap(Comparable [] entries)	{		lastIndex = entries.length;		heap = new Comparable[lastIndex + 1];				// copy given array to data field		for (int index = 0; index < entries.length; index++)			heap[index+1] = entries[index];					// create heap		for (int index = heap.length/2; index > 0; index--)			reheap(index);	} // end constructor// 27.4	public Comparable getMax()	{		Comparable root = null;				if (!isEmpty())			root = heap[1];					return root;	} // end getMax	// 27.4	public boolean isEmpty()	{		return lastIndex < 1;	} // end isEmpty	// 27.4	public int getSize()	{		return lastIndex;	} // end getSize	// 27.4	public void clear()	{		for (; lastIndex > -1; lastIndex--)			heap[lastIndex] = null;		lastIndex = 0;	} // end clear// 27.8	public void add(Comparable newEntry)	{		lastIndex++;				if (lastIndex >= heap.length)			doubleArray(); // expand array					int newIndex = lastIndex;		int parentIndex = newIndex/2;		while ( (newIndex > 1) && newEntry.compareTo(heap[parentIndex]) > 0)		{			heap[newIndex] = heap[parentIndex];			newIndex = parentIndex;			parentIndex = newIndex/2;		} // end while				heap[newIndex] = newEntry;	} // end add// 27.12	public Comparable removeMax()	{		Comparable root = null;		if (!isEmpty())		{			root = heap[1]; // return value			heap[1] = heap[lastIndex]; // form a semiheap			lastIndex--; // decrease size			reheap(1); // transform to a heap		} // end if				return root;	} // end removeMax// 27.11		private void reheap(int rootIndex)	{		boolean done = false;		Comparable orphan = heap[rootIndex];		int largerChildIndex = 2*rootIndex; // index of left child, if any				while (!done && (largerChildIndex <= lastIndex) )		{			int rightChildIndex = largerChildIndex + 1;			if ( (rightChildIndex <= lastIndex) &&			      heap[rightChildIndex].compareTo(heap[largerChildIndex]) > 0)			{	largerChildIndex = rightChildIndex;			}			if (orphan.compareTo(heap[largerChildIndex]) < 0)			{				heap[rootIndex] = heap[largerChildIndex];					rootIndex = largerChildIndex;				largerChildIndex = 2*rootIndex; // index of next left child			}			else				done = true;		} // end while				heap[rootIndex] = orphan;	} // end reheap	private void doubleArray()	{	   Comparable[] oldHeap = heap;	   int oldSize = oldHeap.length;	   	   heap = new Comparable[2*oldSize];	   	   for (int index = 0; index < oldSize; ++index)	        heap[index] = oldHeap[index];	} // end doubleArray	// FOR TESTING	public void display()	{		System.out.println("Heap");		int size = getSize();		for (int i = 1; i <= size; i++)			System.out.print(heap[i] + " " );		System.out.println();	} // end display	} // end MaxHeap