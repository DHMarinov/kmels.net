public Comparable remove(Comparable entry){	Comparable result = null;	boolean found = false;		// locate node that contains a match for entry	BinaryNode currentNode = getRootNode();	BinaryNode parentNode = null;	while (!found && (currentNode != null) )	{		Object currentEntry = currentNode.getData();		int comparison = entry.compareTo(currentEntry);		if (comparison == 0)		{			found = true;			result = (Comparable)currentEntry;		}		else		{			parentNode = currentNode;			if (comparison < 0)				currentNode = (BinaryNode)currentNode.getLeftChild();			else				currentNode = (BinaryNode)currentNode.getRightChild();		} // end if	} // end while		if (found)	{		// Case 1: current node has two children		if (currentNode.hasLeftChild() && currentNode.hasRightChild())		{			// find node with largest entry in left subtree by			// moving as far right in the subtree as possible			BinaryNode leftSubtreeRoot = (BinaryNode)currentNode.getLeftChild();			BinaryNode rightChild = leftSubtreeRoot;			BinaryNode priorNode = currentNode;						while (rightChild.hasRightChild())			{				priorNode = rightChild;				rightChild = (BinaryNode)rightChild.getRightChild();			} // end while						// copy entry from rightmost node to current node			currentNode.setData(rightChild.getData());						// need to remove the rightmost node, so rename it as currentNode			currentNode = rightChild;			parentNode = priorNode; // parent of currentNode		} // end if				// Assertion: current node is the node to be removed; it has at most		// one child; case 1 has been transformed to case 2		// Case 2: current node has at most one child		BinaryNode childNode;		if (currentNode.hasLeftChild())			childNode = (BinaryNode)currentNode.getLeftChild();		else			childNode = (BinaryNode)currentNode.getRightChild();				// Assertion: if currentNode is a leaf, childNode is null		// remove current node		if (currentNode == getRootNode())			setRootNode(childNode);				// else link the parent of the current node to childNode,		// thereby deleting the current node		else if (parentNode.getLeftChild() == currentNode)			parentNode.setLeftChild(childNode);		else			parentNode.setRightChild(childNode);	} // end if		return result;} // end remove