import java.util.Iterator;public class BinarySearchTree extends BinaryTree implements SearchTreeInterface{	public BinarySearchTree()	{		super();	} // end default constructor		public BinarySearchTree(Comparable rootEntry)	{		super();		setRootNode(new BinaryNode(rootEntry));	} // end constructor	public void setTree(Object rootData)	{		throw new UnsupportedOperationException();	} // end setTree	public Comparable getEntry(Comparable entry)	{		return findEntry(getRootNode(), entry);	} // end getEntry		private Comparable findEntry(BinaryNode rootNode, Comparable entry)	{		Comparable result = null;		if (rootNode != null)		{			Object rootEntry = rootNode.getData();			if (entry.equals(rootEntry))				result = (Comparable)rootEntry;			else if (entry.compareTo(rootEntry) < 0)				result = findEntry((BinaryNode)rootNode.getLeftChild(), entry);			else				result = findEntry((BinaryNode)rootNode.getRightChild(), entry);		} // end if				return result;	} // end findEntry		public boolean contains(Comparable entry)	{		return getEntry(entry) != null;	} // end contains		public Comparable add(Comparable newEntry)	{		ReturnObject oldEntry = new ReturnObject(null);		BinaryNode newRoot =		    (BinaryNode)addNode(getRootNode(), newEntry, oldEntry);		setRootNode(newRoot);				return oldEntry.get();	} // end add	/** Task: Adds a new entry to the subtree rooted at a given node.	 *  @param rootNode a reference to the root of a subtree	 *  @param newEntry an object that is the new entry	 *  @param oldEntry an object whose data field is null	 *  @return the root node of the resulting tree; if newEntry	 *  matched an entry that was already in the tree,	 *  oldEntry's data field is that current entry;	 *  otherwise it is null */	private BinaryNode addNode(BinaryNode rootNode, Comparable newEntry, ReturnObject oldEntry)	{		if (rootNode == null)			rootNode = new BinaryNode(newEntry);		else if (newEntry.compareTo(rootNode.getData()) < 0)		{			BinaryNode leftChild = (BinaryNode)rootNode.getLeftChild();			BinaryNode subtreeRoot = addNode(leftChild, newEntry, oldEntry);			rootNode.setLeftChild(subtreeRoot);		}		else if (newEntry.compareTo(rootNode.getData()) > 0)		{			BinaryNode rightChild = (BinaryNode)rootNode.getRightChild();			rightChild = addNode(rightChild, newEntry, oldEntry);			rootNode.setRightChild(rightChild); 		}		else // newEntry matches entry in root		{			Comparable rootEntry = (Comparable)rootNode.getData();			oldEntry.set(rootEntry);			rootNode.setData(newEntry);		} // end if				return rootNode;	} // end addNode		public Comparable remove(Comparable entry)	{		ReturnObject oldEntry = new ReturnObject(null);		BinaryNode newRoot = remove(getRootNode(), entry, oldEntry);		setRootNode(newRoot);		return oldEntry.get();	} // end remove	/** Task: Removes an entry from the tree rooted at a given node.	 *  @param rootNode a reference to the root of a tree	 *  @param entry the object to be removed	 *  @param oldEntry an object whose data field is null	 *  @return the root node of the resulting tree; if entry matches	 *  an entry in the tree, oldEntry's data field is the	 *  entry that was removed from the tree; otherwise it is	 *  null */	private BinaryNode remove(BinaryNode rootNode, Comparable entry, ReturnObject oldEntry)	{		boolean found = false;		if (rootNode != null)		{			Comparable rootData = (Comparable)rootNode.getData();			int comparison = entry.compareTo(rootData);			if (comparison == 0) // entry == root entry			{				oldEntry.set(rootData);				rootNode = (BinaryNode)removeEntry(rootNode);			}			else if (comparison < 0) // entry < root entry			{				BinaryNode leftChild = (BinaryNode)rootNode.getLeftChild();				BinaryNode subtreeRoot = remove(leftChild, entry, oldEntry);				rootNode.setLeftChild(subtreeRoot);			}			else // entry > root entry			{				BinaryNode rightChild = (BinaryNode)rootNode.getRightChild();				rootNode.setRightChild(remove(rightChild, entry, oldEntry));			} // end if		} // end if				return rootNode;	} // end remove	/** Task: Removes the entry in a given root node of a subtree.	 *  @param rootNode the root node of the subtree	 *  @return the root node of the revised subtree */	private BinaryNode removeEntry(BinaryNode rootNode)	{		// Case 1: rootNode has two children		if (rootNode.hasLeftChild() && rootNode.hasRightChild())		{			// find node with largest entry in left subtree			BinaryNode leftSubtreeRoot = (BinaryNode)rootNode.getLeftChild();			BinaryNode largestNode = findLargest(leftSubtreeRoot);						// replace entry in root			rootNode.setData(largestNode.getData());						// remove node with largest entry in left subtree			rootNode.setLeftChild(removeLargest(leftSubtreeRoot));		} // end if				// Case 2: rootNode has at most one child		else if (rootNode.getLeftChild() == null)				rootNode = (BinaryNode)rootNode.getRightChild();		else				rootNode = (BinaryNode)rootNode.getLeftChild();		// Assertion: if rootNode was a leaf, it is now null		return rootNode;	} // end removeEntry	/** Task: Finds the node containing the largest entry in a	 *  given tree	 *  @param rootNode the root node of the tree	 *  @return the node with the largest entry */	private BinaryNode findLargest(BinaryNode rootNode)	{	 	if (rootNode.hasRightChild())			rootNode = findLargest((BinaryNode)rootNode.getRightChild());		return rootNode;	} // end findLargest	/** Task: Removes the node containing the largest entry in a	 *  given tree.	 *  @param rootNode the root node of the tree	 * @return the root node of the revised tree */	private BinaryNode removeLargest(BinaryNode rootNode)	{		if (rootNode.hasRightChild())		{			BinaryNode rightChild = (BinaryNode)rootNode.getRightChild();			BinaryNode root = removeLargest(rightChild);			rootNode.setRightChild(root);		}		else			rootNode = (BinaryNode)rootNode.getLeftChild();					return rootNode;	} // end removeLargest	private class ReturnObject 	{		private Comparable item;					private ReturnObject(Comparable entry)		{			item = entry;		} // end constructor				public Comparable get()		{			return item;		} // end get		public void set(Comparable entry)		{			item = entry;		} // end set			} // end ReturnObject} // end BinarySearchTree