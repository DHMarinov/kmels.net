import java.lang.*; // UnsupportedOperationExceptionimport java.util.*; // Iteratorpublic class AVLTree extends BinarySearchTree                      implements SearchTreeInterface, java.io.Serializable{	public AVLTree()	{		super();	} // end default constructor		public AVLTree(Comparable rootEntry)	{		super(rootEntry);	} // end constructor	public Comparable add(Comparable newEntry)	{		ReturnObject oldEntry = new ReturnObject(null);		BinaryNode newRoot =			(BinaryNode)addNode(getRootNode(), newEntry, oldEntry);		setRootNode(newRoot);				return oldEntry.get();	} // end add		private BinaryNode addNode(BinaryNode rootNode, Comparable newEntry, ReturnObject oldEntry)	{		if (rootNode == null)			rootNode = new BinaryNode(newEntry);		else if (newEntry.compareTo(rootNode.getData()) < 0)		{			BinaryNode leftChild = (BinaryNode)rootNode.getLeftChild();			BinaryNode subtreeRoot = addNode(leftChild, newEntry, oldEntry);			rootNode.setLeftChild(subtreeRoot); 					rootNode = rebalance(rootNode);			}		else if (newEntry.compareTo(rootNode.getData()) > 0)		{			BinaryNode rightChild = (BinaryNode)rootNode.getRightChild();			rootNode.setRightChild(addNode(rightChild, newEntry, oldEntry)); 			rootNode = rebalance(rootNode);			}		else // newEntry matches entry in root		{			Comparable rootEntry = (Comparable)rootNode.getData(); // get current data			oldEntry.set(rootEntry);			rootNode.setData(newEntry);                            // replace current data		} // end if		return rootNode;	}  // end addNode		public Comparable remove(Comparable entry)	{		ReturnObject oldEntry = new ReturnObject(null);		BinaryNode newRoot = remove(getRootNode(), entry, oldEntry);		setRootNode(newRoot);		return oldEntry.get();	} // end remove	/** Task: Removes an entry from the tree rooted at a given node.  	 *  @param rootNode a reference to the root of a tree	 *  @param entry the object to be removed	 *  @param oldEntry an object whose data field is null	 *  @return the root node of the resulting tree; if entry matches	 *  an entry in the tree, oldEntry's data field is the	 *  entry that was removed from the tree; otherwise it is	 *  null */	private BinaryNode remove(BinaryNode rootNode, Comparable entry,				              ReturnObject oldEntry)	{		boolean found = false;		BinaryNode subtreeRoot;		if (rootNode != null)		{			Comparable rootData = (Comparable)rootNode.getData();			int comparison = entry.compareTo(rootData);			if (comparison == 0) // entry == root entry			{				oldEntry.set(rootData);				rootNode = (BinaryNode)removeEntry(rootNode);			}			else if (comparison < 0) // entry < root entry			{				BinaryNode leftChild = (BinaryNode)rootNode.getLeftChild();				subtreeRoot = remove(leftChild, entry, oldEntry);				rootNode.setLeftChild(subtreeRoot);			}			else // entry > root entry			{				BinaryNode rightChild = (BinaryNode)rootNode.getRightChild();				subtreeRoot = remove(rightChild, entry, oldEntry);				rootNode.setRightChild(subtreeRoot);			} // end if							rootNode = rebalance(rootNode);		} // end if				return rootNode;	} // end remove	/** Task: Removes the entry in a given root node of a subtree.	 *  @param rootNode the root node of the subtree	 *  @return the root node of the revised subtree */	private BinaryNode removeEntry(BinaryNode rootNode)	{		// Case 1: rootNode has two children		if (rootNode.hasLeftChild() && rootNode.hasRightChild())		{			// find node with largest entry in left subtree			BinaryNode leftSubtreeRoot = (BinaryNode)rootNode.getLeftChild();			leftSubtreeRoot = removeCopy(leftSubtreeRoot, rootNode);			rootNode.setLeftChild(leftSubtreeRoot);		} // end if		// Case 2: rootNode has at most one child		else if (rootNode.getLeftChild() == null)			rootNode = (BinaryNode)rootNode.getRightChild();		else			rootNode = (BinaryNode)rootNode.getLeftChild();		// Assertion: if rootNode was a leaf, it is now null		return rootNode;	} // end removeEntry	/** Task: Finds the value to copy up to the target and then	 *        removes the copied value.	 *  @param rootNode the root node of the subtree	 *  @param targetNode the node to copy the value to	 *  @return the root node of the revised subtree */	private BinaryNode removeCopy(BinaryNode rootNode, BinaryNode target)	{		BinaryNode rightChild = (BinaryNode)rootNode.getRightChild();		if(rightChild != null)		{			// traverse right looking for inorder predecessor of my target			BinaryNode subtreeRoot = removeCopy(rightChild, target);			rootNode.setRightChild(subtreeRoot);			// rebalance on the way back			rootNode = rebalance(rootNode);		}		else		{			// found the value to copy up			target.setData(rootNode.getData());			// Now dispose of it			rootNode = removeEntry(rootNode);			// No rebalancing needed here.		} // end if				return rootNode;	} // end removeCopy	private BinaryNode rebalance(BinaryNode nodeN)	{		int heightDifference = getHeightDifference(nodeN);				if (heightDifference > 1)		{ 	// left subtree is taller by more than 1			if (getHeightDifference((BinaryNode)nodeN.getLeftChild()) > 0)				// left subtree of left child is taller				nodeN = TreeRotations.rotateRight(nodeN);			else				nodeN = TreeRotations.rotateLeftRight(nodeN);		}		else if (heightDifference < -1)		{	// right subtree is taller by more than 1			if (getHeightDifference((BinaryNode)nodeN.getRightChild()) < 0)				// right subtree of right child is taller				nodeN = TreeRotations.rotateLeft(nodeN);			else				nodeN = TreeRotations.rotateRightLeft(nodeN);		} // end if		// else nodeN is balanced		return nodeN;	} // end rebalance	private BinaryNode rotateRight(BinaryNode nodeN)	{		BinaryNode nodeC = (BinaryNode)nodeN.getLeftChild();		nodeN.setLeftChild(nodeC.getRightChild());		nodeC.setRightChild(nodeN);				return nodeC;	} // end rotateRight		private BinaryNode rotateLeft(BinaryNode nodeN)	{		BinaryNode nodeC = (BinaryNode)nodeN.getRightChild();		nodeN.setRightChild(nodeC.getLeftChild());		nodeC.setLeftChild(nodeN);				return nodeC;	} // end rotateLeft	private BinaryNode rotateRightLeft(BinaryNode nodeN)	{		BinaryNode nodeC = (BinaryNode)nodeN.getRightChild();		nodeN.setRightChild(rotateRight(nodeC));				return rotateLeft(nodeN);	} // end rotateRightLeft		private BinaryNode rotateLeftRight(BinaryNode nodeN)	{		BinaryNode nodeC = (BinaryNode)nodeN.getLeftChild();		nodeN.setLeftChild(rotateLeft(nodeC));		return rotateRight(nodeN);	} // end rotateLeftRight		private int getHeightDifference(BinaryNode node)	{		int result = 0;				if (node != null)		{			BinaryNode left = (BinaryNode)node.getLeftChild();			BinaryNode right = (BinaryNode)node.getRightChild();			int leftHeight, rightHeight;			if (left == null)				leftHeight = 0;			else				leftHeight = left.getHeight();						if (right == null)				rightHeight = 0;			else				rightHeight = right.getHeight();						result = leftHeight - rightHeight;		} // end if					return result;	} // end getHeightDifference		private class ReturnObject 	{		private Comparable item;					private ReturnObject(Comparable entry)		{			item = entry;		} // end constructor				public Comparable get()		{			return item;		} // end get		public void set(Comparable entry)		{			item = entry;		} // end set			} // end ReturnObject// For testing: displays keys in level order	public void display()	{		Iterator nodes = getLevelOrderIterator(); 				int nodesPerLevel = 1;				while (nodes.hasNext())			nodesPerLevel = displayNextLevel(nodesPerLevel, nodes);		} // end display		private int displayNextLevel(int nodesPerLevel, Iterator nodes)	{		int nextLevelCount = 0;		for (int count = 0; count < nodesPerLevel; count++)		{			BinaryNode nextNode = (BinaryNode)nodes.next();			if (nextNode.hasLeftChild())				nextLevelCount++;			if (nextNode.hasRightChild())				nextLevelCount++;			System.out.print(nextNode.getData() + " ");		} // end for		System.out.println();				return nextLevelCount;	} // end displayNextLevel} // end AVLTree